{"version":3,"file":"app.6e35c6f2f27decdb86fc.js","mappings":"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","sources":["webpack://pdf-compressor-pwa/webpack/runtime/chunk loaded","webpack://pdf-compressor-pwa/./src/js/ui-controller.js","webpack://pdf-compressor-pwa/./src/js/pdf-processor.js","webpack://pdf-compressor-pwa/./src/js/storage-manager.js","webpack://pdf-compressor-pwa/./src/js/app.js","webpack://pdf-compressor-pwa/webpack/bootstrap","webpack://pdf-compressor-pwa/webpack/runtime/compat get default export","webpack://pdf-compressor-pwa/webpack/runtime/define property getters","webpack://pdf-compressor-pwa/webpack/runtime/hasOwnProperty shorthand","webpack://pdf-compressor-pwa/webpack/runtime/jsonp chunk loading","webpack://pdf-compressor-pwa/webpack/runtime/nonce","webpack://pdf-compressor-pwa/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// ui-controller.js - Manages the user interface for the PDF Compressor PWA\n// Implements singleton pattern for UI management\n\n/**\n * UIController - Singleton class for managing the user interface\n * Handles all UI interactions, animations, and state management\n */\nclass UIController {\n  /**\n   * Constructor - Initialize UIController as singleton\n   */\n  constructor() {\n    // Ensure only one instance exists\n    if (UIController.instance) {\n      return UIController.instance;\n    }\n    \n    // DOM element cache\n    this.elements = {};\n    \n    // State management\n    this.state = {\n      isDragging: false,\n      isProcessing: false,\n      isMobile: window.innerWidth <= 768,\n      darkMode: this.detectSystemTheme() === 'dark',\n      currentTheme: this.detectSystemTheme()\n    };\n    \n    // Animation frame references\n    this.animationFrame = null;\n    \n    // Initialize the UI controller\n    this.init();\n    \n    // Set instance for singleton pattern\n    UIController.instance = this;\n  }\n\n  /**\n   * Initialize the UI controller\n   */\n  init() {\n    console.log('[UIController] Initializing UI controller');\n    \n    // Cache DOM elements\n    this.cacheElements();\n    \n    // Bind event handlers\n    this.bindEvents();\n    \n    // Setup observers\n    this.setupObservers();\n    \n    // Apply initial theme\n    this.applyTheme();\n    \n    // Handle initial responsive state\n    this.handleResize();\n  }\n\n  /**\n   * Cache frequently used DOM elements\n   */\n  cacheElements() {\n    console.log('[UIController] Caching DOM elements');\n    \n    // Upload area elements\n    this.elements.dropArea = document.getElementById('dropArea');\n    this.elements.fileInput = document.getElementById('fileInput');\n    this.elements.browseBtn = document.getElementById('browseBtn');\n    this.elements.fileInfoPanel = document.getElementById('fileInfoPanel');\n    this.elements.fileName = document.getElementById('fileName');\n    this.elements.fileSize = document.getElementById('fileSize');\n    this.elements.pageCount = document.getElementById('pageCount');\n    this.elements.imageCount = document.getElementById('imageCount');\n    \n    // Option panel elements\n    this.elements.tabs = document.querySelectorAll('.tab');\n    this.elements.tabPanes = document.querySelectorAll('.tab-pane');\n    this.elements.imageCompressionToggle = document.getElementById('imageCompressionToggle');\n    this.elements.qualitySlider = document.getElementById('qualitySlider');\n    this.elements.qualityValue = document.getElementById('qualityValue');\n    this.elements.removeImagesToggle = document.getElementById('removeImagesToggle');\n    this.elements.splitToggle = document.getElementById('splitToggle');\n    this.elements.splitByPages = document.getElementById('splitByPages');\n    this.elements.splitBySize = document.getElementById('splitBySize');\n    this.elements.pageRange = document.getElementById('pageRange');\n    this.elements.fileSizeLimit = document.getElementById('fileSizeLimit');\n    this.elements.pagesInput = document.getElementById('pagesInput');\n    this.elements.sizeInput = document.getElementById('sizeInput');\n    \n    // Action buttons\n    this.elements.resetBtn = document.getElementById('resetBtn');\n    this.elements.processBtn = document.getElementById('processBtn');\n    \n    // Progress elements\n    this.elements.progressSection = document.getElementById('progressSection');\n    this.elements.progressFill = document.getElementById('progressFill');\n    this.elements.progressText = document.getElementById('progressText');\n    \n    // Results elements\n    this.elements.resultsSection = document.getElementById('resultsSection');\n    this.elements.originalSize = document.getElementById('originalSize');\n    this.elements.compressedSize = document.getElementById('compressedSize');\n    this.elements.savings = document.getElementById('savings');\n    this.elements.originalDownload = document.getElementById('originalDownload');\n    this.elements.compressedDownload = document.getElementById('compressedDownload');\n    \n    // Notification elements\n    this.elements.installBanner = document.getElementById('installBanner');\n    this.elements.offlineNotification = document.getElementById('offlineNotification');\n    this.elements.installBtn = document.getElementById('installBtn');\n    this.elements.closeInstallBanner = document.getElementById('closeInstallBanner');\n    \n    // Mobile menu elements\n    this.elements.mobileMenuToggle = document.getElementById('mobileMenuToggle');\n    this.elements.mobileMenu = document.getElementById('mobileMenu');\n  }\n\n  /**\n   * Bind event handlers\n   */\n  bindEvents() {\n    console.log('[UIController] Binding event handlers');\n    \n    // Upload handling events\n    if (this.elements.browseBtn) {\n      this.elements.browseBtn.addEventListener('click', () => {\n        if (this.elements.fileInput) {\n          this.elements.fileInput.click();\n        }\n      });\n    }\n    \n    if (this.elements.fileInput) {\n      this.elements.fileInput.addEventListener('change', (e) => {\n        this.handleFileSelect(e);\n      });\n    }\n    \n    if (this.elements.dropArea) {\n      this.elements.dropArea.addEventListener('dragover', (e) => {\n        e.preventDefault();\n        this.updateUploadArea(true);\n      });\n      \n      this.elements.dropArea.addEventListener('dragleave', () => {\n        this.updateUploadArea(false);\n      });\n      \n      this.elements.dropArea.addEventListener('drop', (e) => {\n        e.preventDefault();\n        this.updateUploadArea(false);\n        this.handleDrop(e);\n      });\n    }\n    \n    // Tab navigation\n    this.setupTabs();\n    \n    // Option controls\n    this.setupOptionControls();\n    \n    // Action buttons\n    if (this.elements.resetBtn) {\n      this.elements.resetBtn.addEventListener('click', () => {\n        this.resetApp();\n      });\n    }\n    \n    if (this.elements.processBtn) {\n      this.elements.processBtn.addEventListener('click', () => {\n        this.handleProcess();\n      });\n    }\n    \n    // Install banner events\n    if (this.elements.installBtn) {\n      this.elements.installBtn.addEventListener('click', () => {\n        this.handleInstall();\n      });\n    }\n    \n    if (this.elements.closeInstallBanner) {\n      this.elements.closeInstallBanner.addEventListener('click', () => {\n        this.hideInstallPrompt();\n      });\n    }\n    \n    // Mobile menu\n    if (this.elements.mobileMenuToggle) {\n      this.elements.mobileMenuToggle.addEventListener('click', () => {\n        this.toggleMobileMenu();\n      });\n    }\n    \n    // Keyboard navigation\n    document.addEventListener('keydown', (e) => {\n      this.handleKeyboardNavigation(e);\n    });\n  }\n\n  /**\n   * Setup observers (Intersection, Resize)\n   */\n  setupObservers() {\n    console.log('[UIController] Setting up observers');\n    \n    // Resize observer for responsive design\n    window.addEventListener('resize', this.debounce(() => {\n      this.handleResize();\n    }, 250));\n    \n    // Intersection observer for animations\n    if ('IntersectionObserver' in window) {\n      const observer = new IntersectionObserver((entries) => {\n        entries.forEach(entry => {\n          if (entry.isIntersecting) {\n            entry.target.classList.add('visible');\n          }\n        });\n      }, {\n        threshold: 0.1\n      });\n      \n      // Observe relevant elements\n      const observeElements = document.querySelectorAll('.upload-container, .options-section, .results-section');\n      observeElements.forEach(el => observer.observe(el));\n    }\n  }\n\n  // === UPLOAD HANDLING ===\n\n  /**\n   * Update upload area state\n   * @param {boolean} isDragging - Whether user is dragging file over drop area\n   */\n  updateUploadArea(isDragging) {\n    if (!this.elements.dropArea) return;\n    \n    this.state.isDragging = isDragging;\n    \n    if (isDragging) {\n      this.elements.dropArea.classList.add('drag-over');\n      this.triggerAnimation('upload-drag-over');\n    } else {\n      this.elements.dropArea.classList.remove('drag-over');\n      this.triggerAnimation('upload-drag-leave');\n    }\n  }\n\n  /**\n   * Show file information\n   * @param {Object} metadata - File metadata\n   */\n  showFileInfo(metadata) {\n    if (!this.elements.fileInfoPanel) return;\n    \n    // Update file info display\n    if (this.elements.fileName) {\n      this.elements.fileName.textContent = metadata.fileName || 'Unknown';\n    }\n    \n    if (this.elements.fileSize) {\n      this.elements.fileSize.textContent = this.formatFileSize(metadata.fileSize || 0);\n    }\n    \n    if (this.elements.pageCount) {\n      this.elements.pageCount.textContent = metadata.pageCount || 'Calculating...';\n    }\n    \n    if (this.elements.imageCount) {\n      this.elements.imageCount.textContent = metadata.imageCount || 'Analyzing...';\n    }\n    \n    // Show file info panel\n    this.elements.fileInfoPanel.style.display = 'block';\n    \n    // Trigger animation\n    this.triggerAnimation('file-info-show');\n  }\n\n  /**\n   * Reset upload area\n   */\n  resetUploadArea() {\n    // Hide file info panel\n    if (this.elements.fileInfoPanel) {\n      this.elements.fileInfoPanel.style.display = 'none';\n    }\n    \n    // Reset file input\n    if (this.elements.fileInput) {\n      this.elements.fileInput.value = '';\n    }\n    \n    // Show drop area\n    if (this.elements.dropArea) {\n      this.elements.dropArea.style.display = 'block';\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('upload-reset');\n  }\n\n  /**\n   * Handle file selection\n   * @param {Event} e - File input change event\n   */\n  handleFileSelect(e) {\n    if (e.target.files && e.target.files.length > 0) {\n      const file = e.target.files[0];\n      this.processSelectedFile(file);\n    }\n  }\n\n  /**\n   * Handle file drop\n   * @param {Event} e - Drop event\n   */\n  handleDrop(e) {\n    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {\n      const file = e.dataTransfer.files[0];\n      this.processSelectedFile(file);\n    }\n  }\n\n  /**\n   * Process selected file\n   * @param {File} file - Selected file\n   */\n  processSelectedFile(file) {\n    // In a real implementation, this would trigger app processing\n    console.log('[UIController] File selected:', file.name);\n    \n    // Show file info (mock data for now)\n    this.showFileInfo({\n      fileName: file.name,\n      fileSize: file.size,\n      pageCount: Math.floor(Math.random() * 100) + 1,\n      imageCount: Math.floor(Math.random() * 20) + 1\n    });\n  }\n\n  // === OPTIONS PANEL ===\n\n  /**\n   * Setup tab navigation\n   */\n  setupTabs() {\n    if (!this.elements.tabs || !this.elements.tabPanes) return;\n    \n    this.elements.tabs.forEach(tab => {\n      tab.addEventListener('click', () => {\n        this.switchTab(tab);\n      });\n    });\n  }\n\n  /**\n   * Switch active tab\n   * @param {Element} clickedTab - The tab that was clicked\n   */\n  switchTab(clickedTab) {\n    // Remove active class from all tabs and panes\n    this.elements.tabs.forEach(t => t.classList.remove('active'));\n    this.elements.tabPanes.forEach(p => p.classList.remove('active'));\n    \n    // Add active class to clicked tab\n    clickedTab.classList.add('active');\n    \n    // Show corresponding pane\n    const tabId = clickedTab.getAttribute('data-tab');\n    const pane = document.getElementById(`${tabId}Tab`);\n    if (pane) {\n      pane.classList.add('active');\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('tab-switch');\n  }\n\n  /**\n   * Setup option controls\n   */\n  setupOptionControls() {\n    // Image compression toggle\n    if (this.elements.imageCompressionToggle) {\n      this.elements.imageCompressionToggle.addEventListener('change', (e) => {\n        this.toggleOption('imageCompression', e.target.checked);\n      });\n    }\n    \n    // Quality slider\n    if (this.elements.qualitySlider && this.elements.qualityValue) {\n      this.elements.qualitySlider.addEventListener('input', (e) => {\n        this.updateQualitySlider(e.target.value);\n      });\n    }\n    \n    // Remove images toggle\n    if (this.elements.removeImagesToggle) {\n      this.elements.removeImagesToggle.addEventListener('change', (e) => {\n        this.toggleOption('removeImages', e.target.checked);\n      });\n    }\n    \n    // Split toggle\n    if (this.elements.splitToggle) {\n      this.elements.splitToggle.addEventListener('change', (e) => {\n        this.toggleOption('splitPDF', e.target.checked);\n        this.toggleSplitControls(e.target.checked);\n      });\n    }\n    \n    // Split method radio buttons\n    if (this.elements.splitByPages && this.elements.splitBySize) {\n      this.elements.splitByPages.addEventListener('change', () => {\n        this.updateSplitControls('pages');\n      });\n      \n      this.elements.splitBySize.addEventListener('change', () => {\n        this.updateSplitControls('size');\n      });\n    }\n    \n    // Page range input\n    if (this.elements.pageRange) {\n      this.elements.pageRange.addEventListener('input', () => {\n        this.validateInputs();\n      });\n    }\n    \n    // File size limit input\n    if (this.elements.fileSizeLimit) {\n      this.elements.fileSizeLimit.addEventListener('input', () => {\n        this.validateInputs();\n      });\n    }\n  }\n\n  /**\n   * Toggle option\n   * @param {string} optionName - Name of the option to toggle\n   * @param {boolean} value - New value for the option\n   */\n  toggleOption(optionName, value) {\n    console.log(`[UIController] Toggling option ${optionName} to ${value}`);\n    \n    // In a real implementation, this would update app state\n    // For now, we'll just log the change\n    \n    // Trigger animation\n    this.triggerAnimation(`option-${optionName}-toggle`);\n  }\n\n  /**\n   * Update quality slider value display\n   * @param {string} value - Slider value\n   */\n  updateQualitySlider(value) {\n    if (this.elements.qualityValue) {\n      this.elements.qualityValue.textContent = value;\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('quality-slider-update');\n  }\n\n  /**\n   * Update split controls based on method\n   * @param {string} method - Split method ('pages' or 'size')\n   */\n  updateSplitControls(method) {\n    if (!this.elements.pagesInput || !this.elements.sizeInput) return;\n    \n    if (method === 'pages') {\n      this.elements.pagesInput.style.display = 'block';\n      this.elements.sizeInput.style.display = 'none';\n    } else {\n      this.elements.pagesInput.style.display = 'none';\n      this.elements.sizeInput.style.display = 'block';\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('split-controls-update');\n  }\n\n  /**\n   * Toggle split controls visibility\n   * @param {boolean} visible - Whether to show split controls\n   */\n  toggleSplitControls(visible) {\n    const splitOptions = document.querySelector('.split-options');\n    if (splitOptions) {\n      splitOptions.style.display = visible ? 'block' : 'none';\n    }\n  }\n\n  /**\n   * Validate input fields\n   * @returns {boolean} - Whether inputs are valid\n   */\n  validateInputs() {\n    let isValid = true;\n    \n    // Validate page range (if visible)\n    if (this.elements.pageRange && this.elements.pageRange.offsetParent !== null) {\n      const pageRange = this.elements.pageRange.value;\n      // Simple validation - in real app, this would be more thorough\n      if (pageRange && !/^\\d+-\\d+$/.test(pageRange)) {\n        isValid = false;\n        this.elements.pageRange.classList.add('invalid');\n      } else {\n        this.elements.pageRange.classList.remove('invalid');\n      }\n    }\n    \n    // Validate file size limit (if visible)\n    if (this.elements.fileSizeLimit && this.elements.fileSizeLimit.offsetParent !== null) {\n      const fileSizeLimit = parseInt(this.elements.fileSizeLimit.value);\n      if (isNaN(fileSizeLimit) || fileSizeLimit < 1 || fileSizeLimit > 500) {\n        isValid = false;\n        this.elements.fileSizeLimit.classList.add('invalid');\n      } else {\n        this.elements.fileSizeLimit.classList.remove('invalid');\n      }\n    }\n    \n    return isValid;\n  }\n\n  // === PROGRESS MANAGEMENT ===\n\n  /**\n   * Show progress section\n   */\n  showProgress() {\n    if (this.elements.progressSection) {\n      this.elements.progressSection.style.display = 'block';\n    }\n    \n    // Hide other sections\n    if (this.elements.fileInfoPanel) {\n      this.elements.fileInfoPanel.style.display = 'none';\n    }\n    \n    this.state.isProcessing = true;\n    \n    // Trigger animation\n    this.triggerAnimation('progress-show');\n  }\n\n  /**\n   * Update progress display\n   * @param {number} percent - Progress percentage (0-100)\n   * @param {string} message - Progress message\n   */\n  updateProgress(percent, message) {\n    if (this.elements.progressFill) {\n      this.elements.progressFill.style.width = `${percent}%`;\n    }\n    \n    if (this.elements.progressText) {\n      this.elements.progressText.textContent = message || `Processing... ${percent}%`;\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('progress-update');\n  }\n\n  /**\n   * Hide progress section\n   */\n  hideProgress() {\n    if (this.elements.progressSection) {\n      this.elements.progressSection.style.display = 'none';\n    }\n    \n    this.state.isProcessing = false;\n    \n    // Trigger animation\n    this.triggerAnimation('progress-hide');\n  }\n\n  // === RESULTS DISPLAY ===\n\n  /**\n   * Show processing results\n   * @param {Object} files - Processed files data\n   */\n  showResults(files) {\n    if (!this.elements.resultsSection) return;\n    \n    // Hide progress\n    this.hideProgress();\n    \n    // Show results section\n    this.elements.resultsSection.style.display = 'block';\n    \n    // Update results display\n    if (files.originalFile && this.elements.originalSize) {\n      this.elements.originalSize.textContent = this.formatFileSize(files.originalFile.size);\n    }\n    \n    if (files.processedFile && this.elements.compressedSize) {\n      this.elements.compressedSize.textContent = this.formatFileSize(files.processedFile.size);\n    }\n    \n    if (files.savings && this.elements.savings) {\n      this.elements.savings.textContent = this.formatFileSize(files.savings.savingsBytes) + \n        ` (${files.savings.savingsPercentage}% reduction)`;\n    }\n    \n    // Setup download handlers\n    if (this.elements.originalDownload) {\n      this.elements.originalDownload.addEventListener('click', (e) => {\n        e.preventDefault();\n        this.handleDownload(files.originalFile);\n      });\n    }\n    \n    if (this.elements.compressedDownload) {\n      this.elements.compressedDownload.addEventListener('click', (e) => {\n        e.preventDefault();\n        this.handleDownload(files.processedFile);\n      });\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('results-show');\n  }\n\n  /**\n   * Create result card for a file\n   * @param {File} file - File to create card for\n   * @returns {Element} - Result card element\n   */\n  createResultCard(file) {\n    const card = document.createElement('div');\n    card.className = 'result-card';\n    \n    card.innerHTML = `\n      <div class=\"result-card-header\">\n        <h4>${file.name}</h4>\n        <span class=\"file-size\">${this.formatFileSize(file.size)}</span>\n      </div>\n      <div class=\"result-card-actions\">\n        <button class=\"download-btn\" data-file-id=\"${file.id}\">Download</button>\n      </div>\n    `;\n    \n    return card;\n  }\n\n  /**\n   * Handle file download\n   * @param {File} file - File to download\n   */\n  handleDownload(file) {\n    if (!file) return;\n    \n    // Create download link\n    const url = URL.createObjectURL(file);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = file.name;\n    document.body.appendChild(a);\n    a.click();\n    \n    // Clean up\n    setTimeout(() => {\n      document.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    }, 100);\n    \n    // Trigger animation\n    this.triggerAnimation('file-download');\n  }\n\n  /**\n   * Clear results display\n   */\n  clearResults() {\n    if (this.elements.resultsSection) {\n      this.elements.resultsSection.style.display = 'none';\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('results-clear');\n  }\n\n  // === NOTIFICATIONS ===\n\n  /**\n   * Show notification message\n   * @param {string} message - Notification message\n   * @param {string} type - Notification type ('info', 'success', 'warning', 'error')\n   */\n  showNotification(message, type = 'info') {\n    // Create notification element\n    const notification = document.createElement('div');\n    notification.className = `notification notification-${type}`;\n    notification.textContent = message;\n    \n    // Add close button\n    const closeBtn = document.createElement('button');\n    closeBtn.innerHTML = '&times;';\n    closeBtn.className = 'notification-close';\n    closeBtn.addEventListener('click', () => {\n      notification.remove();\n    });\n    \n    notification.appendChild(closeBtn);\n    \n    // Add to document\n    document.body.appendChild(notification);\n    \n    // Auto-remove after 5 seconds\n    setTimeout(() => {\n      if (notification.parentNode) {\n        notification.remove();\n      }\n    }, 5000);\n    \n    // Trigger animation\n    this.triggerAnimation('notification-show');\n  }\n\n  /**\n   * Show offline mode notification\n   */\n  showOfflineMode() {\n    if (this.elements.offlineNotification) {\n      this.elements.offlineNotification.style.display = 'block';\n      this.elements.offlineNotification.classList.add('visible');\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('offline-show');\n  }\n\n  /**\n   * Hide offline mode notification\n   */\n  hideOfflineMode() {\n    if (this.elements.offlineNotification) {\n      this.elements.offlineNotification.style.display = 'none';\n      this.elements.offlineNotification.classList.remove('visible');\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('offline-hide');\n  }\n\n  /**\n   * Show update available notification\n   */\n  showUpdateAvailable() {\n    this.showNotification('A new version is available. Please refresh to update.', 'info');\n    \n    // Trigger animation\n    this.triggerAnimation('update-show');\n  }\n\n  /**\n   * Show install prompt\n   */\n  showInstallPrompt() {\n    if (this.elements.installBanner) {\n      this.elements.installBanner.style.display = 'flex';\n      this.elements.installBanner.classList.add('visible');\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('install-show');\n  }\n\n  /**\n   * Hide install prompt\n   */\n  hideInstallPrompt() {\n    if (this.elements.installBanner) {\n      this.elements.installBanner.style.display = 'none';\n      this.elements.installBanner.classList.remove('visible');\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('install-hide');\n  }\n\n  /**\n   * Handle install button click\n   */\n  handleInstall() {\n    // In a real implementation, this would trigger the PWA install prompt\n    console.log('[UIController] Install button clicked');\n    \n    // For now, we'll just hide the banner\n    this.hideInstallPrompt();\n    \n    // Trigger animation\n    this.triggerAnimation('install-handle');\n  }\n\n  // === RESPONSIVENESS ===\n\n  /**\n   * Handle window resize\n   */\n  handleResize() {\n    this.state.isMobile = window.innerWidth <= 768;\n    \n    // Adapt layout\n    this.adaptLayout();\n    \n    // Trigger animation\n    this.triggerAnimation('resize');\n  }\n\n  /**\n   * Toggle mobile menu\n   */\n  toggleMobileMenu() {\n    if (this.elements.mobileMenu) {\n      const isOpen = this.elements.mobileMenu.classList.contains('open');\n      if (isOpen) {\n        this.elements.mobileMenu.classList.remove('open');\n      } else {\n        this.elements.mobileMenu.classList.add('open');\n      }\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('mobile-menu-toggle');\n  }\n\n  /**\n   * Adapt layout for current screen size\n   */\n  adaptLayout() {\n    // Adjust layout based on screen size\n    const container = document.querySelector('.upload-container');\n    if (container) {\n      if (this.state.isMobile) {\n        container.classList.add('mobile-layout');\n      } else {\n        container.classList.remove('mobile-layout');\n      }\n    }\n    \n    // Trigger animation\n    this.triggerAnimation('layout-adapt');\n  }\n\n  // === ACCESSIBILITY ===\n\n  /**\n   * Handle keyboard navigation\n   * @param {Event} e - Keyboard event\n   */\n  handleKeyboardNavigation(e) {\n    // Handle Escape key\n    if (e.key === 'Escape') {\n      // Close modals, menus, etc.\n      this.hideInstallPrompt();\n      \n      // Trigger animation\n      this.triggerAnimation('escape-key');\n    }\n    \n    // Handle Tab key for focus management\n    if (e.key === 'Tab') {\n      this.manageFocus(e);\n    }\n  }\n\n  /**\n   * Manage focus for accessibility\n   * @param {Event} e - Keyboard event\n   */\n  manageFocus(e) {\n    // In a real implementation, this would manage focus traps and keyboard navigation\n    console.log('[UIController] Managing focus');\n  }\n\n  /**\n   * Update ARIA attributes\n   * @param {Element} element - Element to update\n   * @param {string} attribute - ARIA attribute to update\n   * @param {string} value - New value\n   */\n  updateAria(element, attribute, value) {\n    if (element) {\n      element.setAttribute(attribute, value);\n    }\n  }\n\n  /**\n   * Announce message to screen readers\n   * @param {string} message - Message to announce\n   */\n  announceToScreenReader(message) {\n    // Create aria-live region if it doesn't exist\n    let liveRegion = document.getElementById('screen-reader-announcements');\n    if (!liveRegion) {\n      liveRegion = document.createElement('div');\n      liveRegion.id = 'screen-reader-announcements';\n      liveRegion.setAttribute('aria-live', 'polite');\n      liveRegion.setAttribute('aria-atomic', 'true');\n      liveRegion.style.position = 'absolute';\n      liveRegion.style.left = '-10000px';\n      document.body.appendChild(liveRegion);\n    }\n    \n    // Set message\n    liveRegion.textContent = message;\n  }\n\n  // === ANIMATIONS ===\n\n  /**\n   * Trigger animation using requestAnimationFrame\n   * @param {string} animationName - Name of animation to trigger\n   */\n  triggerAnimation(animationName) {\n    // Cancel any existing animation frame\n    if (this.animationFrame) {\n      cancelAnimationFrame(this.animationFrame);\n    }\n    \n    // Trigger animation\n    this.animationFrame = requestAnimationFrame(() => {\n      console.log(`[UIController] Animation triggered: ${animationName}`);\n      // In a real implementation, this would trigger CSS transitions or animations\n    });\n  }\n\n  /**\n   * Debounce function to limit rate of function execution\n   * @param {Function} func - Function to debounce\n   * @param {number} wait - Wait time in milliseconds\n   * @returns {Function} Debounced function\n   */\n  debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n      const later = () => {\n        clearTimeout(timeout);\n        func(...args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  }\n\n  // === THEME MANAGEMENT ===\n\n  /**\n   * Toggle dark mode\n   */\n  toggleDarkMode() {\n    this.state.darkMode = !this.state.darkMode;\n    this.applyTheme();\n    this.savePreference();\n    \n    // Trigger animation\n    this.triggerAnimation('theme-toggle');\n  }\n\n  /**\n   * Apply current theme\n   */\n  applyTheme() {\n    if (this.state.darkMode) {\n      document.body.classList.add('dark-mode');\n    } else {\n      document.body.classList.remove('dark-mode');\n    }\n  }\n\n  /**\n   * Save theme preference\n   */\n  savePreference() {\n    try {\n      localStorage.setItem('pdf-compressor-theme', this.state.darkMode ? 'dark' : 'light');\n    } catch (e) {\n      console.warn('[UIController] Could not save theme preference:', e);\n    }\n  }\n\n  /**\n   * Detect system theme preference\n   * @returns {string} - 'dark' or 'light'\n   */\n  detectSystemTheme() {\n    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {\n      return 'dark';\n    }\n    return 'light';\n  }\n\n  // === UTILITY METHODS ===\n\n  /**\n   * Format file size for display\n   * @param {number} bytes - File size in bytes\n   * @returns {string} Formatted file size\n   */\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  /**\n   * Handle process button click\n   */\n  handleProcess() {\n    console.log('[UIController] Process button clicked');\n    \n    // Show progress\n    this.showProgress();\n    \n    // Simulate processing\n    let progress = 0;\n    const interval = setInterval(() => {\n      progress += 5;\n      this.updateProgress(progress, `Processing... ${progress}%`);\n      \n      if (progress >= 100) {\n        clearInterval(interval);\n        // In a real implementation, this would show actual results\n        this.showResults({\n          originalFile: { size: 1000000, name: 'original.pdf' },\n          processedFile: { size: 700000, name: 'compressed.pdf' },\n          savings: { savingsBytes: 300000, savingsPercentage: '30.00' }\n        });\n      }\n    }, 100);\n  }\n\n  /**\n   * Reset application state\n   */\n  resetApp() {\n    console.log('[UIController] Resetting application');\n    \n    // Reset UI\n    this.resetUploadArea();\n    this.hideProgress();\n    this.clearResults();\n    \n    // Trigger animation\n    this.triggerAnimation('app-reset');\n  }\n}\n\n// Export singleton instance\nconst uiController = new UIController();\nexport { uiController as UIController };","// PDFProcessor.js - Handles PDF processing logic using pdf-lib\n// This implementation provides comprehensive PDF manipulation capabilities\n\nimport { PDFDocument, rgb } from 'pdf-lib';\n\n/**\n * PDFProcessor - Class for processing PDF files with various operations\n * Uses pdf-lib for PDF manipulation and provides methods for compression, splitting, and optimization\n */\nexport class PDFProcessor {\n  /**\n   * Constructor - Initialize PDFProcessor\n   */\n  constructor() {\n    this.worker = null;\n    this.isWorkerSupported = typeof Worker !== 'undefined';\n    this.taskCounter = 0;\n  }\n\n  /**\n   * Initialize Web Worker for heavy operations\n   * @returns {Promise<Worker>} - Initialized worker\n   */\n  async initWorker() {\n    if (!this.isWorkerSupported) {\n      throw new Error('Web Workers not supported in this environment');\n    }\n    \n    if (this.worker) {\n      return this.worker;\n    }\n    \n    try {\n      // For webpack, we need to use a different approach to load the worker\n      // We'll dynamically create the worker using Blob URL\n      const workerBlob = new Blob([`importScripts('${window.location.origin}/src/js/pdf-worker.js');`], {\n        type: 'application/javascript'\n      });\n      const workerUrl = URL.createObjectURL(workerBlob);\n      \n      // Create worker\n      this.worker = new Worker(workerUrl);\n      \n      // Set up message handling\n      this.setupWorkerMessaging();\n      \n      // Wait for worker to be ready\n      await new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('Worker initialization timeout'));\n        }, 5000);\n        \n        const readyHandler = (event) => {\n          if (event.data.type === 'WORKER_READY') {\n            clearTimeout(timeout);\n            this.worker.removeEventListener('message', readyHandler);\n            console.log('[PDFProcessor] Web Worker initialized');\n            resolve(this.worker);\n          }\n        };\n        \n        this.worker.addEventListener('message', readyHandler);\n      });\n      \n      // Clean up the blob URL\n      URL.revokeObjectURL(workerUrl);\n      \n      return this.worker;\n    } catch (error) {\n      console.error('[PDFProcessor] Error initializing worker:', error);\n      this.worker = null;\n      throw new Error(`Failed to initialize worker: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Set up worker message handling\n   */\n  setupWorkerMessaging() {\n    if (!this.worker) return;\n    \n    this.worker.onmessage = (event) => {\n      const { type, taskId, result, error, percentage, message, performance } = event.data;\n      \n      // Handle different message types\n      switch (type) {\n        case 'PROGRESS_UPDATE':\n          // Progress updates are handled by specific task handlers\n          break;\n          \n        case 'PROCESSING_COMPLETED':\n          // Find and resolve the corresponding promise\n          if (this.pendingTasks && this.pendingTasks[taskId]) {\n            const { resolve } = this.pendingTasks[taskId];\n            delete this.pendingTasks[taskId];\n            resolve({ result, performance });\n          }\n          break;\n          \n        case 'ERROR':\n          // Find and reject the corresponding promise\n          if (this.pendingTasks && this.pendingTasks[taskId]) {\n            const { reject } = this.pendingTasks[taskId];\n            delete this.pendingTasks[taskId];\n            reject(new Error(error));\n          }\n          break;\n          \n        case 'TASK_QUEUED':\n        case 'PROCESSING_STARTED':\n        case 'TASK_CANCELLED':\n        case 'TASK_NOT_FOUND':\n        case 'STATUS_UPDATE':\n        case 'WORKER_READY':\n        case 'WORKER_CLEANUP_COMPLETED':\n          // These are informational messages\n          console.log(`[PDFProcessor] Worker message: ${type}`);\n          break;\n          \n        default:\n          console.warn(`[PDFProcessor] Unknown worker message type: ${type}`);\n      }\n    };\n    \n    this.worker.onerror = (error) => {\n      console.error('[PDFProcessor] Worker error:', error);\n    };\n    \n    // Track pending tasks\n    this.pendingTasks = {};\n  }\n  \n  /**\n   * Generate unique task ID\n   * @returns {string} - Unique task ID\n   */\n  generateTaskId() {\n    return `task-${Date.now()}-${++this.taskCounter}`;\n  }\n\n  /**\n   * Load a PDF file and extract metadata\n   * @param {File} file - The PDF file to load\n   * @returns {Promise<Object>} - Object containing PDF document and metadata\n   */\n  async loadPDF(file) {\n    try {\n      console.log('[PDFProcessor] Loading PDF file:', file.name);\n      \n      // Validate PDF file\n      if (!this.validatePDF(file)) {\n        throw new Error('Invalid PDF file');\n      }\n      \n      // Convert File to ArrayBuffer\n      const arrayBuffer = await file.arrayBuffer();\n      \n      // Load PDF document using pdf-lib\n      const pdfDoc = await PDFDocument.load(arrayBuffer, { \n        updateMetadata: false,\n        parseSpeed: 'fast' // For better performance with large files\n      });\n      \n      // Extract metadata\n      const metadata = this.extractMetadata(pdfDoc, file);\n      \n      console.log('[PDFProcessor] PDF loaded successfully');\n      \n      return {\n        pdfDoc,\n        metadata,\n        arrayBuffer\n      };\n    } catch (error) {\n      console.error('[PDFProcessor] Error loading PDF:', error);\n      throw new Error(`Failed to load PDF: ${error.message}`);\n    }\n  }\n\n  /**\n   * Compress images in a PDF document\n   * @param {PDFDocument} pdfDoc - The PDF document to process\n   * @param {number} quality - Image quality (10-100)\n   * @param {Function} progressCallback - Callback for progress updates\n   * @returns {Promise<PDFDocument>} - Processed PDF document\n   */\n  async compressImages(pdfDoc, quality, progressCallback = null) {\n    try {\n      console.log(`[PDFProcessor] Compressing images with quality: ${quality}`);\n      \n      // Try to use worker if available\n      if (this.isWorkerSupported) {\n        try {\n          await this.initWorker();\n          return await this.compressImagesWithWorker(pdfDoc, quality, progressCallback);\n        } catch (workerError) {\n          console.warn('[PDFProcessor] Worker failed, falling back to main thread:', workerError);\n        }\n      }\n      \n      // Fallback to main thread processing\n      const pages = pdfDoc.getPages();\n      const total = pages.length;\n      \n      // Iterate through each page\n      for (let i = 0; i < pages.length; i++) {\n        const page = pages[i];\n        \n        // In a real implementation, we would:\n        // 1. Identify XObjects (images) on the page\n        // 2. Extract images\n        // 3. Compress using Canvas API\n        // 4. Re-embed compressed images\n        \n        // For demonstration, we'll simulate the process\n        if (progressCallback) {\n          progressCallback({\n            page: i + 1,\n            total,\n            percentage: Math.round(((i + 1) / total) * 100)\n          });\n        }\n        \n        // Simulate processing time\n        await new Promise(resolve => setTimeout(resolve, 100));\n      }\n      \n      console.log('[PDFProcessor] Image compression completed');\n      return pdfDoc;\n    } catch (error) {\n      console.error('[PDFProcessor] Error compressing images:', error);\n      throw new Error(`Failed to compress images: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Compress images using Web Worker\n   * @param {PDFDocument} pdfDoc - The PDF document to process\n   * @param {number} quality - Image quality (10-100)\n   * @param {Function} progressCallback - Callback for progress updates\n   * @returns {Promise<PDFDocument>} - Processed PDF document\n   */\n  async compressImagesWithWorker(pdfDoc, quality, progressCallback = null) {\n    const taskId = this.generateTaskId();\n    const pdfBytes = await pdfDoc.save();\n    \n    // Create a promise to handle the async response\n    const taskPromise = new Promise((resolve, reject) => {\n      // Store the promise callbacks\n      if (!this.pendingTasks) this.pendingTasks = {};\n      this.pendingTasks[taskId] = { resolve, reject };\n      \n      // Set up progress handler if callback provided\n      if (progressCallback) {\n        const progressHandler = (event) => {\n          if (event.data.type === 'PROGRESS_UPDATE' && event.data.taskId === taskId) {\n            progressCallback({\n              percentage: event.data.percentage,\n              message: event.data.message\n            });\n          }\n        };\n        this.worker.addEventListener('message', progressHandler);\n        \n        // Remove listener when task completes\n        const cleanupHandler = (event) => {\n          if ((event.data.type === 'PROCESSING_COMPLETED' || event.data.type === 'ERROR') && \n              event.data.taskId === taskId) {\n            this.worker.removeEventListener('message', progressHandler);\n            this.worker.removeEventListener('message', cleanupHandler);\n          }\n        };\n        this.worker.addEventListener('message', cleanupHandler);\n      }\n    });\n    \n    // Send task to worker\n    this.worker.postMessage({\n      type: 'PROCESS_COMPRESS_IMAGES',\n      taskId,\n      payload: {\n        pdfBytes,\n        quality,\n        taskId\n      }\n    });\n    \n    // Wait for result\n    const { result } = await taskPromise;\n    \n    // Load the processed PDF\n    const processedPdf = await PDFDocument.load(result.pdfBytes);\n    return processedPdf;\n  }\n\n  /**\n   * Remove images from a PDF document\n   * @param {PDFDocument} pdfDoc - The PDF document to process\n   * @returns {Promise<PDFDocument>} - Processed PDF document\n   */\n  async removeImages(pdfDoc) {\n    try {\n      console.log('[PDFProcessor] Removing images from PDF');\n      \n      // Try to use worker if available\n      if (this.isWorkerSupported) {\n        try {\n          await this.initWorker();\n          return await this.removeImagesWithWorker(pdfDoc);\n        } catch (workerError) {\n          console.warn('[PDFProcessor] Worker failed, falling back to main thread:', workerError);\n        }\n      }\n      \n      // Fallback to main thread processing\n      const pages = pdfDoc.getPages();\n      \n      // Iterate through each page\n      for (let i = 0; i < pages.length; i++) {\n        const page = pages[i];\n        \n        // In a real implementation, we would:\n        // 1. Identify XObject references (images)\n        // 2. Remove image references from page content\n        // 3. Clean up unused objects\n        \n        // For demonstration, we'll simulate the process\n        console.log(`[PDFProcessor] Processing page ${i + 1} for image removal`);\n        \n        // Simulate processing time\n        await new Promise(resolve => setTimeout(resolve, 50));\n      }\n      \n      // Clean up unused objects\n      // pdfDoc.flush();\n      \n      console.log('[PDFProcessor] Image removal completed');\n      return pdfDoc;\n    } catch (error) {\n      console.error('[PDFProcessor] Error removing images:', error);\n      throw new Error(`Failed to remove images: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Remove images using Web Worker\n   * @param {PDFDocument} pdfDoc - The PDF document to process\n   * @returns {Promise<PDFDocument>} - Processed PDF document\n   */\n  async removeImagesWithWorker(pdfDoc) {\n    const taskId = this.generateTaskId();\n    const pdfBytes = await pdfDoc.save();\n    \n    // Create a promise to handle the async response\n    const taskPromise = new Promise((resolve, reject) => {\n      // Store the promise callbacks\n      if (!this.pendingTasks) this.pendingTasks = {};\n      this.pendingTasks[taskId] = { resolve, reject };\n    });\n    \n    // Send task to worker\n    this.worker.postMessage({\n      type: 'PROCESS_REMOVE_IMAGES',\n      taskId,\n      payload: {\n        pdfBytes,\n        taskId\n      }\n    });\n    \n    // Wait for result\n    const { result } = await taskPromise;\n    \n    // Load the processed PDF\n    const processedPdf = await PDFDocument.load(result.pdfBytes);\n    return processedPdf;\n  }\n\n  /**\n   * Split PDF by page range\n   * @param {PDFDocument} pdfDoc - The PDF document to split\n   * @param {number} startPage - Starting page (1-based)\n   * @param {number} endPage - Ending page (1-based)\n   * @returns {Promise<PDFDocument>} - New PDF document with selected pages\n   */\n  async splitByPages(pdfDoc, startPage, endPage) {\n    try {\n      console.log(`[PDFProcessor] Splitting PDF by pages: ${startPage}-${endPage}`);\n      \n      // Try to use worker if available\n      if (this.isWorkerSupported) {\n        try {\n          await this.initWorker();\n          return await this.splitByPagesWithWorker(pdfDoc, startPage, endPage);\n        } catch (workerError) {\n          console.warn('[PDFProcessor] Worker failed, falling back to main thread:', workerError);\n        }\n      }\n      \n      // Validate page range\n      const pageCount = pdfDoc.getPageCount();\n      if (startPage < 1 || endPage > pageCount || startPage > endPage) {\n        throw new Error(`Invalid page range. PDF has ${pageCount} pages.`);\n      }\n      \n      // Create new PDF document\n      const newPdfDoc = await PDFDocument.create();\n      \n      // Copy pages to new document\n      for (let i = startPage; i <= endPage; i++) {\n        // Copy page (1-based index to 0-based)\n        const [copiedPage] = await newPdfDoc.copyPages(pdfDoc, [i - 1]);\n        newPdfDoc.addPage(copiedPage);\n      }\n      \n      // In a real implementation, we would also:\n      // 1. Copy bookmarks\n      // 2. Copy links\n      // 3. Preserve metadata where possible\n      \n      console.log('[PDFProcessor] PDF splitting by pages completed');\n      return newPdfDoc;\n    } catch (error) {\n      console.error('[PDFProcessor] Error splitting by pages:', error);\n      throw new Error(`Failed to split PDF by pages: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Split PDF by pages using Web Worker\n   * @param {PDFDocument} pdfDoc - The PDF document to split\n   * @param {number} startPage - Starting page (1-based)\n   * @param {number} endPage - Ending page (1-based)\n   * @returns {Promise<PDFDocument>} - New PDF document with selected pages\n   */\n  async splitByPagesWithWorker(pdfDoc, startPage, endPage) {\n    const taskId = this.generateTaskId();\n    const pdfBytes = await pdfDoc.save();\n    \n    // Create a promise to handle the async response\n    const taskPromise = new Promise((resolve, reject) => {\n      // Store the promise callbacks\n      if (!this.pendingTasks) this.pendingTasks = {};\n      this.pendingTasks[taskId] = { resolve, reject };\n    });\n    \n    // Send task to worker\n    this.worker.postMessage({\n      type: 'PROCESS_SPLIT_PDF',\n      taskId,\n      payload: {\n        pdfBytes,\n        startPage,\n        endPage,\n        taskId\n      }\n    });\n    \n    // Wait for result\n    const { result } = await taskPromise;\n    \n    // Load the processed PDF\n    const processedPdf = await PDFDocument.load(result.pdfBytes);\n    return processedPdf;\n  }\n\n  /**\n   * Split PDF by file size\n   * @param {PDFDocument} pdfDoc - The PDF document to split\n   * @param {number} maxSizeMB - Maximum size per chunk in MB\n   * @param {Function} progressCallback - Callback for progress updates\n   * @returns {Promise<Array<PDFDocument>>} - Array of PDF documents\n   */\n  async splitBySize(pdfDoc, maxSizeMB, progressCallback = null) {\n    try {\n      console.log(`[PDFProcessor] Splitting PDF by size: ${maxSizeMB}MB`);\n      \n      const maxSizeBytes = maxSizeMB * 1024 * 1024;\n      const chunks = [];\n      const pageCount = pdfDoc.getPageCount();\n      \n      // Estimate initial chunk size using binary search approach\n      let startPage = 1;\n      let endPage = pageCount;\n      \n      while (startPage <= pageCount) {\n        // Estimate optimal end page for current chunk\n        let chunkEndPage = await this.estimateOptimalChunkEnd(pdfDoc, startPage, endPage, maxSizeBytes);\n        \n        // Create chunk\n        const chunkDoc = await this.splitByPages(pdfDoc, startPage, chunkEndPage);\n        chunks.push(chunkDoc);\n        \n        // Report progress\n        if (progressCallback) {\n          progressCallback({\n            chunk: chunks.length,\n            totalChunks: 'calculating',\n            percentage: Math.round((chunkEndPage / pageCount) * 100)\n          });\n        }\n        \n        // Move to next chunk\n        startPage = chunkEndPage + 1;\n        \n        // Break if we've processed all pages\n        if (startPage > pageCount) {\n          break;\n        }\n      }\n      \n      console.log(`[PDFProcessor] PDF splitting by size completed. Created ${chunks.length} chunks`);\n      return chunks;\n    } catch (error) {\n      console.error('[PDFProcessor] Error splitting by size:', error);\n      throw new Error(`Failed to split PDF by size: ${error.message}`);\n    }\n  }\n\n  /**\n   * Estimate optimal chunk end page\n   * @param {PDFDocument} pdfDoc - The PDF document\n   * @param {number} startPage - Starting page\n   * @param {number} endPage - Ending page\n   * @param {number} maxSizeBytes - Maximum size in bytes\n   * @returns {Promise<number>} - Optimal end page\n   */\n  async estimateOptimalChunkEnd(pdfDoc, startPage, endPage, maxSizeBytes) {\n    // Simplified estimation - in a real implementation, this would be more sophisticated\n    let low = startPage;\n    let high = endPage;\n    let optimalEnd = startPage;\n    \n    // Binary search for optimal end page\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      \n      // Estimate size for pages startPage to mid\n      // In a real implementation, we would actually measure this\n      const estimatedSize = (mid - startPage + 1) * 100000; // Simplified estimation\n      \n      if (estimatedSize <= maxSizeBytes) {\n        optimalEnd = mid;\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    \n    return optimalEnd;\n  }\n\n  /**\n   * Optimize PDF for web viewing\n   * @param {PDFDocument} pdfDoc - The PDF document to optimize\n   * @returns {Promise<PDFDocument>} - Optimized PDF document\n   */\n  async optimizePDF(pdfDoc) {\n    try {\n      console.log('[PDFProcessor] Optimizing PDF');\n      \n      // Try to use worker if available\n      if (this.isWorkerSupported) {\n        try {\n          await this.initWorker();\n          return await this.optimizePDFWithWorker(pdfDoc);\n        } catch (workerError) {\n          console.warn('[PDFProcessor] Worker failed, falling back to main thread:', workerError);\n        }\n      }\n      \n      // In a real implementation, we would:\n      // 1. Remove duplicate objects\n      // 2. Compress streams\n      // 3. Subset fonts\n      // 4. Linearize for fast web view\n      \n      // For demonstration, we'll simulate the process\n      await new Promise(resolve => setTimeout(resolve, 500));\n      \n      console.log('[PDFProcessor] PDF optimization completed');\n      return pdfDoc;\n    } catch (error) {\n      console.error('[PDFProcessor] Error optimizing PDF:', error);\n      throw new Error(`Failed to optimize PDF: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Optimize PDF using Web Worker\n   * @param {PDFDocument} pdfDoc - The PDF document to optimize\n   * @returns {Promise<PDFDocument>} - Optimized PDF document\n   */\n  async optimizePDFWithWorker(pdfDoc) {\n    const taskId = this.generateTaskId();\n    const pdfBytes = await pdfDoc.save();\n    \n    // Create a promise to handle the async response\n    const taskPromise = new Promise((resolve, reject) => {\n      // Store the promise callbacks\n      if (!this.pendingTasks) this.pendingTasks = {};\n      this.pendingTasks[taskId] = { resolve, reject };\n    });\n    \n    // Send task to worker\n    this.worker.postMessage({\n      type: 'PROCESS_OPTIMIZE_PDF',\n      taskId,\n      payload: {\n        pdfBytes,\n        taskId\n      }\n    });\n    \n    // Wait for result\n    const { result } = await taskPromise;\n    \n    // Load the processed PDF\n    const processedPdf = await PDFDocument.load(result.pdfBytes);\n    return processedPdf;\n  }\n\n  /**\n   * Process PDF with selected options\n   * @param {File} file - The PDF file to process\n   * @param {Object} options - Processing options\n   * @returns {Promise<Object>} - Processing result\n   */\n  async processPDF(file, options) {\n    try {\n      console.log('[PDFProcessor] Processing PDF with options:', options);\n      \n      // Load PDF\n      const { pdfDoc, metadata } = await this.loadPDF(file);\n      \n      let processedDoc = pdfDoc;\n      \n      // Apply image compression if requested\n      if (options.imageCompression) {\n        processedDoc = await this.compressImages(processedDoc, options.imageQuality);\n      }\n      \n      // Remove images if requested\n      if (options.removeImages) {\n        processedDoc = await this.removeImages(processedDoc);\n      }\n      \n      // Split PDF if requested\n      if (options.splitPDF) {\n        if (options.splitMethod === 'pages' && options.pageRange) {\n          const [start, end] = options.pageRange.split('-').map(Number);\n          processedDoc = await this.splitByPages(processedDoc, start, end);\n        } else if (options.splitMethod === 'size') {\n          // For size-based splitting, we return multiple documents\n          const chunks = await this.splitBySize(processedDoc, options.fileSizeLimit);\n          // For simplicity, we'll return the first chunk\n          processedDoc = chunks[0];\n        }\n      }\n      \n      // Optimize PDF\n      processedDoc = await this.optimizePDF(processedDoc);\n      \n      // Serialize to bytes\n      const pdfBytes = await processedDoc.save();\n      \n      // Create new file\n      const newFileName = this.generateFileName(file.name, options);\n      const processedFile = new File([pdfBytes], newFileName, {\n        type: 'application/pdf'\n      });\n      \n      // Estimate compression savings\n      const savings = this.estimateCompression(file.size, processedFile.size);\n      \n      return {\n        originalFile: file,\n        processedFile,\n        metadata,\n        savings,\n        processingTime: Date.now()\n      };\n    } catch (error) {\n      console.error('[PDFProcessor] Error processing PDF:', error);\n      throw new Error(`Failed to process PDF: ${error.message}`);\n    }\n  }\n\n  /**\n   * Validate if a file is a PDF\n   * @param {File} file - The file to validate\n   * @returns {boolean} - True if the file is a valid PDF\n   */\n  validatePDF(file) {\n    // Check file type\n    if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {\n      return false;\n    }\n    \n    // Check file size (basic validation)\n    if (file.size === 0) {\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Extract metadata from PDF document\n   * @param {PDFDocument} pdfDoc - The PDF document\n   * @param {File} file - The original file\n   * @returns {Object} - Extracted metadata\n   */\n  extractMetadata(pdfDoc, file) {\n    try {\n      const info = pdfDoc.getTitle() || file.name.replace('.pdf', '');\n      const author = pdfDoc.getAuthor() || 'Unknown';\n      const subject = pdfDoc.getSubject() || '';\n      const keywords = pdfDoc.getKeywords() || '';\n      const creator = pdfDoc.getCreator() || '';\n      const producer = pdfDoc.getProducer() || '';\n      const creationDate = pdfDoc.getCreationDate();\n      const modificationDate = pdfDoc.getModificationDate();\n      const pageCount = pdfDoc.getPageCount();\n      \n      return {\n        title: info,\n        author,\n        subject,\n        keywords,\n        creator,\n        producer,\n        creationDate: creationDate || new Date(),\n        modificationDate: modificationDate || new Date(),\n        pageCount,\n        fileSize: file.size\n      };\n    } catch (error) {\n      console.warn('[PDFProcessor] Error extracting metadata:', error);\n      return {\n        title: file.name.replace('.pdf', ''),\n        author: 'Unknown',\n        subject: '',\n        keywords: '',\n        creator: '',\n        producer: '',\n        creationDate: new Date(),\n        modificationDate: new Date(),\n        pageCount: pdfDoc ? pdfDoc.getPageCount() : 0,\n        fileSize: file.size\n      };\n    }\n  }\n\n  /**\n   * Generate thumbnail for PDF\n   * @param {PDFDocument} pdfDoc - The PDF document\n   * @param {number} pageNumber - Page number for thumbnail\n   * @returns {Promise<string>} - Data URL of thumbnail\n   */\n  async generateThumbnail(pdfDoc, pageNumber = 1) {\n    try {\n      // In a real implementation, we would render the page to a canvas\n      // and convert it to a data URL\n      \n      // For demonstration, we'll return a placeholder\n      return 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8/5+hHgAHggJ/PchI7wAAAABJRU5ErkJggg==';\n    } catch (error) {\n      console.warn('[PDFProcessor] Error generating thumbnail:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Estimate compression savings\n   * @param {number} originalSize - Original file size in bytes\n   * @param {number} compressedSize - Compressed file size in bytes\n   * @returns {Object} - Savings information\n   */\n  estimateCompression(originalSize, compressedSize) {\n    const savingsBytes = originalSize - compressedSize;\n    const savingsPercentage = originalSize > 0 ? (savingsBytes / originalSize) * 100 : 0;\n    \n    return {\n      originalSize,\n      compressedSize,\n      savingsBytes,\n      savingsPercentage: savingsPercentage.toFixed(2)\n    };\n  }\n\n  /**\n   * Generate new file name based on processing options\n   * @param {string} originalName - Original file name\n   * @param {Object} options - Processing options\n   * @returns {string} - New file name\n   */\n  generateFileName(originalName, options) {\n    const nameWithoutExt = originalName.replace(/\\.[^/.]+$/, \"\");\n    const extension = '.pdf';\n    \n    let suffix = '';\n    if (options.imageCompression) {\n      suffix += `-compressed-${options.imageQuality}`;\n    }\n    if (options.removeImages) {\n      suffix += '-no-images';\n    }\n    if (options.splitPDF) {\n      suffix += '-split';\n    }\n    \n    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');\n    \n    return `${nameWithoutExt}${suffix}-${timestamp}${extension}`;\n  }\n\n  /**\n   * Terminate Web Worker\n   */\n  terminateWorker() {\n    if (this.worker) {\n      this.worker.terminate();\n      this.worker = null;\n      console.log('[PDFProcessor] Web Worker terminated');\n    }\n  }\n}","// StorageManager.js - Comprehensive storage management for PDF Compressor PWA\n\n/**\n * StorageManager - Singleton class for managing all storage operations\n * Handles IndexedDB, Cache API, settings, quota management, and data synchronization\n */\nexport class StorageManager {\n  /**\n   * Constructor - Initialize StorageManager as singleton\n   */\n  constructor() {\n    // Ensure only one instance exists (singleton pattern)\n    if (StorageManager.instance) {\n      return StorageManager.instance;\n    }\n    \n    // Database configuration\n    this.dbName = 'PDFCompressorDB';\n    this.dbVersion = 1;\n    this.db = null;\n    \n    // Cache configuration\n    this.cacheName = 'pdf-compressor-cache-v1';\n    \n    // Session storage prefix\n    this.sessionPrefix = 'pdf-compressor-';\n    \n    // Storage quota monitoring\n    this.storageQuota = null;\n    this.storageUsage = null;\n    \n    // Set instance for singleton pattern\n    StorageManager.instance = this;\n  }\n  \n  /**\n   * Initialize the storage manager\n   * @returns {Promise<void>}\n   */\n  async init() {\n    try {\n      await this.initDB();\n      await this.initCache();\n      this.setupEventListeners();\n      console.log('[StorageManager] Initialized successfully');\n    } catch (error) {\n      console.error('[StorageManager] Initialization error:', error);\n      throw new Error(`Storage initialization failed: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Initialize IndexedDB database\n   * @returns {Promise<void>}\n   */\n  async initDB() {\n    return new Promise((resolve, reject) => {\n      if (!window.indexedDB) {\n        reject(new Error('IndexedDB is not supported in this browser'));\n        return;\n      }\n      \n      const request = indexedDB.open(this.dbName, this.dbVersion);\n      \n      request.onerror = (event) => {\n        console.error('[StorageManager] Database error:', event.target.error);\n        reject(event.target.error);\n      };\n      \n      request.onsuccess = (event) => {\n        this.db = event.target.result;\n        console.log('[StorageManager] Database initialized successfully');\n        resolve();\n      };\n      \n      request.onupgradeneeded = (event) => {\n        this.db = event.target.result;\n        \n        // Create object stores\n        if (!this.db.objectStoreNames.contains('files')) {\n          const fileStore = this.db.createObjectStore('files', { keyPath: 'id' });\n          fileStore.createIndex('fileName', 'fileName', { unique: false });\n          fileStore.createIndex('dateAdded', 'dateAdded', { unique: false });\n        }\n        \n        if (!this.db.objectStoreNames.contains('results')) {\n          const resultsStore = this.db.createObjectStore('results', { keyPath: 'id' });\n          resultsStore.createIndex('originalFileId', 'originalFileId', { unique: false });\n          resultsStore.createIndex('dateProcessed', 'dateProcessed', { unique: false });\n        }\n        \n        if (!this.db.objectStoreNames.contains('settings')) {\n          const settingsStore = this.db.createObjectStore('settings', { keyPath: 'key' });\n        }\n        \n        console.log('[StorageManager] Database upgraded');\n      };\n    });\n  }\n  \n  /**\n   * Initialize Cache API\n   * @returns {Promise<void>}\n   */\n  async initCache() {\n    if ('caches' in window) {\n      try {\n        await caches.open(this.cacheName);\n        console.log('[StorageManager] Cache initialized successfully');\n      } catch (error) {\n        console.error('[StorageManager] Cache initialization error:', error);\n      }\n    }\n  }\n  \n  /**\n   * Setup event listeners for storage changes\n   */\n  setupEventListeners() {\n    // Listen for storage changes\n    window.addEventListener('storage', this.handleStorageChange.bind(this));\n    \n    // Periodically monitor storage usage\n    setInterval(() => {\n      this.monitorStorageUsage();\n    }, 300000); // Every 5 minutes\n  }\n  \n  // === FILE METHODS ===\n  \n  /**\n   * Save a file to IndexedDB\n   * @param {File} file - The file to save\n   * @param {Object} metadata - File metadata\n   * @returns {Promise<string>} - File ID\n   */\n  async saveFile(file, metadata) {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['files'], 'readwrite');\n      const store = transaction.objectStore('files');\n      \n      // Convert file to ArrayBuffer for storage\n      const arrayBuffer = await file.arrayBuffer();\n      \n      const fileData = {\n        id: this.generateId(),\n        fileName: file.name,\n        fileType: file.type,\n        fileSize: file.size,\n        data: arrayBuffer,\n        metadata: metadata,\n        dateAdded: new Date()\n      };\n      \n      await this.putInStore(store, fileData);\n      console.log(`[StorageManager] File saved: ${file.name}`);\n      return fileData.id;\n    } catch (error) {\n      console.error('[StorageManager] Error saving file:', error);\n      this.handleStorageError(error, 'saveFile');\n      throw error;\n    }\n  }\n  \n  /**\n   * Get a file from IndexedDB\n   * @param {string} id - File ID\n   * @returns {Promise<Object|null>} - File data or null if not found\n   */\n  async getFile(id) {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['files'], 'readonly');\n      const store = transaction.objectStore('files');\n      \n      const result = await this.getFromStore(store, id);\n      \n      if (result) {\n        // Convert ArrayBuffer back to Blob for use\n        const blob = new Blob([result.data], { type: result.fileType });\n        return {\n          ...result,\n          blob: blob\n        };\n      }\n      \n      return result;\n    } catch (error) {\n      console.error('[StorageManager] Error getting file:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Delete a file from IndexedDB\n   * @param {string} id - File ID\n   * @returns {Promise<void>}\n   */\n  async deleteFile(id) {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['files'], 'readwrite');\n      const store = transaction.objectStore('files');\n      \n      await this.deleteFromStore(store, id);\n      console.log(`[StorageManager] File deleted: ${id}`);\n    } catch (error) {\n      console.error('[StorageManager] Error deleting file:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get all files from IndexedDB\n   * @returns {Promise<Array>} - Array of files\n   */\n  async getAllFiles() {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['files'], 'readonly');\n      const store = transaction.objectStore('files');\n      \n      const files = await this.getAllFromStore(store);\n      \n      // Convert ArrayBuffers back to Blobs\n      return files.map(file => ({\n        ...file,\n        blob: new Blob([file.data], { type: file.fileType })\n      }));\n    } catch (error) {\n      console.error('[StorageManager] Error getting all files:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Clear old files from IndexedDB\n   * @param {number} daysOld - Files older than this will be deleted\n   * @returns {Promise<number>} - Number of files deleted\n   */\n  async clearOldFiles(daysOld) {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - daysOld);\n      \n      const transaction = this.db.transaction(['files'], 'readwrite');\n      const store = transaction.objectStore('files');\n      \n      // Get all files\n      const allFiles = await this.getAllFromStore(store);\n      \n      // Filter old files\n      const oldFiles = allFiles.filter(file => new Date(file.dateAdded) < cutoffDate);\n      \n      // Delete old files\n      let deletedCount = 0;\n      for (const file of oldFiles) {\n        await this.deleteFromStore(store, file.id);\n        deletedCount++;\n      }\n      \n      console.log(`[StorageManager] Cleared ${deletedCount} old files`);\n      return deletedCount;\n    } catch (error) {\n      console.error('[StorageManager] Error clearing old files:', error);\n      throw error;\n    }\n  }\n  \n  // === RESULTS METHODS ===\n  \n  /**\n   * Save processing result to IndexedDB\n   * @param {Object} result - Processing result data\n   * @returns {Promise<string>} - Result ID\n   */\n  async saveResult(result) {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['results'], 'readwrite');\n      const store = transaction.objectStore('results');\n      \n      // Convert files to ArrayBuffer for storage\n      const originalArrayBuffer = await result.originalFile.arrayBuffer();\n      const processedArrayBuffer = await result.processedFile.arrayBuffer();\n      \n      const resultData = {\n        id: this.generateId(),\n        originalFile: {\n          name: result.originalFile.name,\n          type: result.originalFile.type,\n          size: result.originalFile.size,\n          data: originalArrayBuffer\n        },\n        processedFile: {\n          name: result.processedFile.name,\n          type: result.processedFile.type,\n          size: result.processedFile.size,\n          data: processedArrayBuffer\n        },\n        metadata: result.metadata,\n        savings: result.savings,\n        processingTime: result.processingTime,\n        dateProcessed: new Date()\n      };\n      \n      await this.putInStore(store, resultData);\n      console.log('[StorageManager] Result saved');\n      return resultData.id;\n    } catch (error) {\n      console.error('[StorageManager] Error saving result:', error);\n      this.handleStorageError(error, 'saveResult');\n      throw error;\n    }\n  }\n  \n  /**\n   * Get a processing result from IndexedDB\n   * @param {string} id - Result ID\n   * @returns {Promise<Object|null>} - Result data or null if not found\n   */\n  async getResult(id) {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['results'], 'readonly');\n      const store = transaction.objectStore('results');\n      \n      const result = await this.getFromStore(store, id);\n      \n      if (result) {\n        // Convert ArrayBuffers back to Blobs\n        return {\n          ...result,\n          originalFile: new Blob([result.originalFile.data], { type: result.originalFile.type }),\n          processedFile: new Blob([result.processedFile.data], { type: result.processedFile.type })\n        };\n      }\n      \n      return result;\n    } catch (error) {\n      console.error('[StorageManager] Error getting result:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get all processing results from IndexedDB\n   * @returns {Promise<Array>} - Array of results\n   */\n  async getAllResults() {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['results'], 'readonly');\n      const store = transaction.objectStore('results');\n      \n      const results = await this.getAllFromStore(store);\n      \n      // Convert ArrayBuffers back to Blobs\n      return results.map(result => ({\n        ...result,\n        originalFile: new Blob([result.originalFile.data], { type: result.originalFile.type }),\n        processedFile: new Blob([result.processedFile.data], { type: result.processedFile.type })\n      }));\n    } catch (error) {\n      console.error('[StorageManager] Error getting all results:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Delete a processing result from IndexedDB\n   * @param {string} id - Result ID\n   * @returns {Promise<void>}\n   */\n  async deleteResult(id) {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['results'], 'readwrite');\n      const store = transaction.objectStore('results');\n      \n      await this.deleteFromStore(store, id);\n      console.log(`[StorageManager] Result deleted: ${id}`);\n    } catch (error) {\n      console.error('[StorageManager] Error deleting result:', error);\n      throw error;\n    }\n  }\n  \n  // === CACHE API METHODS ===\n  \n  /**\n   * Cache a processed PDF\n   * @param {Blob} blob - The PDF blob to cache\n   * @param {string} filename - The filename to use as cache key\n   * @returns {Promise<void>}\n   */\n  async cacheProcessedPDF(blob, filename) {\n    try {\n      if ('caches' in window) {\n        const cache = await caches.open(this.cacheName);\n        const response = new Response(blob);\n        await cache.put(filename, response);\n        console.log(`[StorageManager] Cached PDF: ${filename}`);\n      }\n    } catch (error) {\n      console.error('[StorageManager] Error caching PDF:', error);\n      this.handleStorageError(error, 'cacheProcessedPDF');\n    }\n  }\n  \n  /**\n   * Get a cached PDF\n   * @param {string} filename - The filename to retrieve\n   * @returns {Promise<Blob|null>} - The cached PDF blob or null if not found\n   */\n  async getCachedPDF(filename) {\n    try {\n      if ('caches' in window) {\n        const cache = await caches.open(this.cacheName);\n        const response = await cache.match(filename);\n        \n        if (response) {\n          return await response.blob();\n        }\n      }\n      return null;\n    } catch (error) {\n      console.error('[StorageManager] Error getting cached PDF:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Clear all cached data\n   * @returns {Promise<void>}\n   */\n  async clearCache() {\n    try {\n      if ('caches' in window) {\n        await caches.delete(this.cacheName);\n        await this.initCache(); // Reinitialize cache\n        console.log('[StorageManager] Cache cleared');\n      }\n    } catch (error) {\n      console.error('[StorageManager] Error clearing cache:', error);\n    }\n  }\n  \n  /**\n   * Get cache size\n   * @returns {Promise<number>} - Cache size in bytes\n   */\n  async getCacheSize() {\n    try {\n      if ('caches' in window) {\n        const cache = await caches.open(this.cacheName);\n        const keys = await cache.keys();\n        let size = 0;\n        \n        for (const key of keys) {\n          const response = await cache.match(key);\n          if (response) {\n            const blob = await response.blob();\n            size += blob.size;\n          }\n        }\n        \n        return size;\n      }\n      return 0;\n    } catch (error) {\n      console.error('[StorageManager] Error getting cache size:', error);\n      return 0;\n    }\n  }\n  \n  // === SETTINGS STORAGE ===\n  \n  /**\n   * Save settings to IndexedDB\n   * @param {Object} settings - Settings object to save\n   * @returns {Promise<void>}\n   */\n  async saveSettings(settings) {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['settings'], 'readwrite');\n      const store = transaction.objectStore('settings');\n      \n      const settingsData = {\n        key: 'userSettings',\n        value: settings,\n        lastUpdated: new Date()\n      };\n      \n      await this.putInStore(store, settingsData);\n      console.log('[StorageManager] Settings saved');\n      \n      // Also save to localStorage as backup\n      this.syncWithLocalStorage(settings);\n    } catch (error) {\n      console.error('[StorageManager] Error saving settings:', error);\n      this.handleStorageError(error, 'saveSettings');\n      throw error;\n    }\n  }\n  \n  /**\n   * Load settings from IndexedDB\n   * @returns {Promise<Object>} - Settings object\n   */\n  async loadSettings() {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['settings'], 'readonly');\n      const store = transaction.objectStore('settings');\n      \n      const result = await this.getFromStore(store, 'userSettings');\n      \n      if (result) {\n        return result.value;\n      }\n      \n      // Fallback to localStorage\n      const localStorageSettings = localStorage.getItem(`${this.sessionPrefix}settings`);\n      if (localStorageSettings) {\n        return JSON.parse(localStorageSettings);\n      }\n      \n      return {};\n    } catch (error) {\n      console.error('[StorageManager] Error loading settings:', error);\n      return {};\n    }\n  }\n  \n  /**\n   * Reset settings to default\n   * @returns {Promise<void>}\n   */\n  async resetSettings() {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      const transaction = this.db.transaction(['settings'], 'readwrite');\n      const store = transaction.objectStore('settings');\n      \n      await this.deleteFromStore(store, 'userSettings');\n      \n      // Also clear localStorage\n      localStorage.removeItem(`${this.sessionPrefix}settings`);\n      \n      console.log('[StorageManager] Settings reset to default');\n    } catch (error) {\n      console.error('[StorageManager] Error resetting settings:', error);\n      throw error;\n    }\n  }\n  \n  // === QUOTA MANAGEMENT ===\n  \n  /**\n   * Check storage quota\n   * @returns {Promise<Object>} - Storage quota information\n   */\n  async checkStorageQuota() {\n    try {\n      if ('storage' in navigator && 'estimate' in navigator.storage) {\n        const estimate = await navigator.storage.estimate();\n        this.storageQuota = estimate.quota;\n        this.storageUsage = estimate.usage;\n        \n        return {\n          quota: estimate.quota,\n          usage: estimate.usage,\n          percentage: estimate.usage && estimate.quota ? \n            Math.round((estimate.usage / estimate.quota) * 100) : 0\n        };\n      }\n      return { quota: null, usage: null, percentage: 0 };\n    } catch (error) {\n      console.error('[StorageManager] Error checking storage quota:', error);\n      return { quota: null, usage: null, percentage: 0 };\n    }\n  }\n  \n  /**\n   * Request persistent storage\n   * @returns {Promise<boolean>} - Whether persistent storage was granted\n   */\n  async requestPersistentStorage() {\n    try {\n      if ('storage' in navigator && 'persist' in navigator.storage) {\n        const persistent = await navigator.storage.persist();\n        console.log(`[StorageManager] Persistent storage granted: ${persistent}`);\n        return persistent;\n      }\n      return false;\n    } catch (error) {\n      console.error('[StorageManager] Error requesting persistent storage:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Monitor storage usage\n   * @returns {Promise<void>}\n   */\n  async monitorStorageUsage() {\n    try {\n      const quotaInfo = await this.checkStorageQuota();\n      \n      // Warn if storage is over 80% full\n      if (quotaInfo.percentage > 80) {\n        console.warn(`[StorageManager] Storage is ${quotaInfo.percentage}% full`);\n        // In a real app, this would trigger a UI notification\n      }\n      \n      console.log(`[StorageManager] Storage usage: ${quotaInfo.percentage}%`);\n    } catch (error) {\n      console.error('[StorageManager] Error monitoring storage usage:', error);\n    }\n  }\n  \n  // === TEMPORARY STORAGE ===\n  \n  /**\n   * Save data to session storage\n   * @param {string} key - Storage key\n   * @param {any} value - Data to store\n   * @returns {boolean} - Whether the operation succeeded\n   */\n  saveToSession(key, value) {\n    try {\n      const fullKey = `${this.sessionPrefix}${key}`;\n      sessionStorage.setItem(fullKey, JSON.stringify(value));\n      return true;\n    } catch (error) {\n      console.error('[StorageManager] Error saving to session storage:', error);\n      this.handleStorageError(error, 'saveToSession');\n      return false;\n    }\n  }\n  \n  /**\n   * Get data from session storage\n   * @param {string} key - Storage key\n   * @returns {any} - Stored data or null\n   */\n  getFromSession(key) {\n    try {\n      const fullKey = `${this.sessionPrefix}${key}`;\n      const item = sessionStorage.getItem(fullKey);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      console.error('[StorageManager] Error getting from session storage:', error);\n      return null;\n    }\n  }\n  \n  /**\n   * Clear session storage\n   * @returns {void}\n   */\n  clearSession() {\n    try {\n      // Only clear items with our prefix\n      Object.keys(sessionStorage).forEach(key => {\n        if (key.startsWith(this.sessionPrefix)) {\n          sessionStorage.removeItem(key);\n        }\n      });\n      console.log('[StorageManager] Session storage cleared');\n    } catch (error) {\n      console.error('[StorageManager] Error clearing session storage:', error);\n    }\n  }\n  \n  // === EXPORT/IMPORT ===\n  \n  /**\n   * Export all data as JSON\n   * @returns {Promise<Blob>} - JSON blob of all data\n   */\n  async exportData() {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      // Get all data from IndexedDB\n      const files = await this.getAllFiles();\n      const settings = await this.loadSettings();\n      \n      // Get session storage data\n      const sessionData = {};\n      Object.keys(sessionStorage).forEach(key => {\n        if (key.startsWith(this.sessionPrefix)) {\n          const cleanKey = key.replace(this.sessionPrefix, '');\n          sessionData[cleanKey] = this.getFromSession(cleanKey);\n        }\n      });\n      \n      const exportData = {\n        files: files.map(file => ({\n          ...file,\n          // Convert ArrayBuffer to base64 for export\n          data: this.arrayBufferToBase64(file.data)\n        })),\n        settings,\n        sessionData,\n        exportDate: new Date().toISOString()\n      };\n      \n      const json = JSON.stringify(exportData, null, 2);\n      const blob = new Blob([json], { type: 'application/json' });\n      \n      console.log('[StorageManager] Data exported');\n      return blob;\n    } catch (error) {\n      console.error('[StorageManager] Error exporting data:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Import data from JSON file\n   * @param {File} file - JSON file to import\n   * @returns {Promise<void>}\n   */\n  async importData(file) {\n    try {\n      if (!this.db) {\n        throw new Error('Database not initialized');\n      }\n      \n      // Read file as text\n      const text = await file.text();\n      const importData = JSON.parse(text);\n      \n      // Import files\n      if (importData.files && Array.isArray(importData.files)) {\n        const transaction = this.db.transaction(['files'], 'readwrite');\n        const store = transaction.objectStore('files');\n        \n        for (const file of importData.files) {\n          // Convert base64 back to ArrayBuffer\n          file.data = this.base64ToArrayBuffer(file.data);\n          await this.putInStore(store, file);\n        }\n      }\n      \n      // Import settings\n      if (importData.settings) {\n        await this.saveSettings(importData.settings);\n      }\n      \n      // Import session data\n      if (importData.sessionData) {\n        Object.keys(importData.sessionData).forEach(key => {\n          this.saveToSession(key, importData.sessionData[key]);\n        });\n      }\n      \n      console.log('[StorageManager] Data imported successfully');\n    } catch (error) {\n      console.error('[StorageManager] Error importing data:', error);\n      throw error;\n    }\n  }\n  \n  // === SYNCHRONIZATION ===\n  \n  /**\n   * Synchronize settings with localStorage\n   * @param {Object} settings - Settings to sync\n   * @returns {void}\n   */\n  syncWithLocalStorage(settings = null) {\n    try {\n      if (settings) {\n        localStorage.setItem(`${this.sessionPrefix}settings`, JSON.stringify(settings));\n      } else {\n        // Sync from IndexedDB to localStorage\n        this.loadSettings().then(settings => {\n          if (Object.keys(settings).length > 0) {\n            localStorage.setItem(`${this.sessionPrefix}settings`, JSON.stringify(settings));\n          }\n        });\n      }\n    } catch (error) {\n      console.error('[StorageManager] Error syncing with localStorage:', error);\n    }\n  }\n  \n  /**\n   * Handle storage change events\n   * @param {StorageEvent} event - Storage change event\n   * @returns {void}\n   */\n  handleStorageChange(event) {\n    if (event.key && event.key.startsWith(this.sessionPrefix)) {\n      console.log(`[StorageManager] Storage changed: ${event.key}`);\n      // In a real app, this would trigger appropriate UI updates\n    }\n  }\n  \n  // === CLEANUP ===\n  \n  /**\n   * Perform cleanup operations\n   * @param {number} daysOld - Files older than this will be deleted\n   * @returns {Promise<void>}\n   */\n  async cleanup(daysOld = 7) {\n    try {\n      // Clear old files\n      await this.clearOldFiles(daysOld);\n      \n      // Monitor storage usage\n      await this.monitorStorageUsage();\n      \n      console.log('[StorageManager] Cleanup completed');\n    } catch (error) {\n      console.error('[StorageManager] Error during cleanup:', error);\n    }\n  }\n  \n  /**\n   * Perform garbage collection\n   * @returns {Promise<void>}\n   */\n  async garbageCollect() {\n    try {\n      // Close database connection if needed\n      if (this.db) {\n        this.db.close();\n        this.db = null;\n      }\n      \n      // Reinitialize\n      await this.initDB();\n      \n      console.log('[StorageManager] Garbage collection completed');\n    } catch (error) {\n      console.error('[StorageManager] Error during garbage collection:', error);\n    }\n  }\n  \n  // === ERROR HANDLING ===\n  \n  /**\n   * Handle storage errors\n   * @param {Error} error - The error that occurred\n   * @param {string} operation - The operation that failed\n   * @returns {void}\n   */\n  handleStorageError(error, operation) {\n    if (error.name === 'QuotaExceededError') {\n      console.error(`[StorageManager] Storage quota exceeded during ${operation}`);\n      // In a real app, this would trigger a UI notification\n      // and possibly cleanup operations\n    } else {\n      console.error(`[StorageManager] Storage error during ${operation}:`, error);\n    }\n    \n    // Attempt to use memory storage as fallback\n    this.useMemoryStorageFallback();\n  }\n  \n  /**\n   * Use memory storage as fallback\n   * @returns {void}\n   */\n  useMemoryStorageFallback() {\n    console.warn('[StorageManager] Using memory storage as fallback');\n    // In a real implementation, this would switch to\n    // storing data in memory when persistent storage fails\n  }\n  \n  // === HELPER METHODS ===\n  \n  /**\n   * Generate unique ID\n   * @returns {string} - Unique ID\n   */\n  generateId() {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\n  }\n  \n  /**\n   * Put data in IndexedDB store\n   * @param {IDBObjectStore} store - The object store\n   * @param {any} data - Data to store\n   * @returns {Promise<void>}\n   */\n  putInStore(store, data) {\n    return new Promise((resolve, reject) => {\n      const request = store.put(data);\n      \n      request.onsuccess = () => resolve();\n      request.onerror = (event) => reject(event.target.error);\n    });\n  }\n  \n  /**\n   * Get data from IndexedDB store\n   * @param {IDBObjectStore} store - The object store\n   * @param {string} key - Key to retrieve\n   * @returns {Promise<any>} - Retrieved data\n   */\n  getFromStore(store, key) {\n    return new Promise((resolve, reject) => {\n      const request = store.get(key);\n      \n      request.onsuccess = (event) => resolve(event.target.result || null);\n      request.onerror = (event) => reject(event.target.error);\n    });\n  }\n  \n  /**\n   * Delete data from IndexedDB store\n   * @param {IDBObjectStore} store - The object store\n   * @param {string} key - Key to delete\n   * @returns {Promise<void>}\n   */\n  deleteFromStore(store, key) {\n    return new Promise((resolve, reject) => {\n      const request = store.delete(key);\n      \n      request.onsuccess = () => resolve();\n      request.onerror = (event) => reject(event.target.error);\n    });\n  }\n  \n  /**\n   * Get all data from IndexedDB store\n   * @param {IDBObjectStore} store - The object store\n   * @returns {Promise<Array>} - All data in store\n   */\n  getAllFromStore(store) {\n    return new Promise((resolve, reject) => {\n      const request = store.getAll();\n      \n      request.onsuccess = (event) => resolve(event.target.result || []);\n      request.onerror = (event) => reject(event.target.error);\n    });\n  }\n  \n  /**\n   * Convert ArrayBuffer to base64\n   * @param {ArrayBuffer} buffer - Buffer to convert\n   * @returns {string} - Base64 string\n   */\n  arrayBufferToBase64(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < bytes.byteLength; i++) {\n      binary += String.fromCharCode(bytes[i]);\n    }\n    return btoa(binary);\n  }\n  \n  /**\n   * Convert base64 to ArrayBuffer\n   * @param {string} base64 - Base64 string to convert\n   * @returns {ArrayBuffer} - ArrayBuffer\n   */\n  base64ToArrayBuffer(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes.buffer;\n  }\n}\n\n// Export singleton instance\nconst storageManager = new StorageManager();\nexport { storageManager };\n","import { UIController } from './ui-controller.js';\nimport { PDFProcessor } from './pdf-processor.js';\nimport { StorageManager } from './storage-manager.js';\n\n// Initialize storage manager\nconst storageManager = new StorageManager();\n\n/**\n * PDF Compressor PWA - Main Application Class\n * Handles initialization, file processing, state management, and PWA features\n */\nclass PDFCompressorApp {\n  /**\n   * Constructor - Initialize app properties and start initialization\n   */\n  constructor() {\n    // Core components\n    this.pdfProcessor = null;\n    this.storageManager = null;\n    this.uiController = null;\n    \n    // Application state\n    this.state = {\n      currentFile: null,\n      pdfDocument: null,\n      processingOptions: {\n        imageCompression: true,\n        imageQuality: 70,\n        removeImages: false,\n        splitPDF: false,\n        splitMethod: 'pages',\n        pageRange: '',\n        fileSizeLimit: 10\n      },\n      processingQueue: [],\n      isOnline: navigator.onLine,\n      isProcessing: false,\n      isVisible: true\n    };\n    \n    // Performance tracking\n    this.performance = {\n      startTime: null,\n      endTime: null,\n      memoryUsage: null\n    };\n    \n    // PWA features\n    this.deferredPrompt = null;\n    this.serviceWorkerRegistration = null;\n    \n    // Initialize the application\n    this.initializeApp();\n  }\n\n  /**\n   * Initialize the entire application\n   * Checks API support, loads libraries, initializes components\n   */\n  async initializeApp() {\n    try {\n      console.log('[PDFCompressor] Initializing application...');\n      \n      // Check for required API support\n      if (!this.checkAPISupport()) {\n        throw new Error('Required APIs not supported in this browser');\n      }\n      \n      // Load external libraries\n      await this.loadLibraries();\n      \n      // Initialize core components\n      this.pdfProcessor = new PDFProcessor();\n      this.storageManager = storageManager;\n      await this.storageManager.init();\n      this.uiController = new UIController();\n      \n      // Setup event listeners\n      this.setupEventListeners();\n      \n      // Register service worker for PWA functionality\n      await this.registerServiceWorker();\n      \n      // Setup PWA features\n      this.setupPWAFeatures();\n      \n      // Handle file sharing if launched from share target\n      this.handleShareTarget();\n      \n      // Handle file opening if launched from file handler\n      this.handleFileHandler();\n      \n      console.log('[PDFCompressor] Application initialized successfully');\n    } catch (error) {\n      console.error('[PDFCompressor] Initialization error:', error);\n      this.showErrorMessage('Failed to initialize application: ' + error.message);\n    }\n  }\n\n  /**\n   * Check if required APIs are supported\n   * @returns {boolean} True if all required APIs are supported\n   */\n  checkAPISupport() {\n    const requiredAPIs = [\n      'File',\n      'Blob',\n      'ArrayBuffer',\n      'Worker',\n      'indexedDB',\n      'caches'\n    ];\n    \n    for (const api of requiredAPIs) {\n      if (!(api in window)) {\n        console.error(`[PDFCompressor] Required API not supported: ${api}`);\n        return false;\n      }\n    }\n    \n    // Check for File API specific methods\n    if (!window.FileReader || !window.FileList) {\n      console.error('[PDFCompressor] File API not fully supported');\n      return false;\n    }\n    \n    // Check for Blob API specific methods\n    if (!window.Blob || !Blob.prototype.arrayBuffer) {\n      console.error('[PDFCompressor] Blob API not fully supported');\n      return false;\n    }\n    \n    console.log('[PDFCompressor] All required APIs supported');\n    return true;\n  }\n\n  /**\n   * Load external libraries dynamically\n   */\n  async loadLibraries() {\n    try {\n      console.log('[PDFCompressor] Loading external libraries...');\n      \n      // In a real implementation, we might load libraries dynamically\n      // For now, we're relying on the CDN scripts in index.html\n      // But we could implement dynamic loading like this:\n      /*\n      const pdfLibScript = document.createElement('script');\n      pdfLibScript.src = 'https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js';\n      document.head.appendChild(pdfLibScript);\n      \n      const pdfJsScript = document.createElement('script');\n      pdfJsScript.src = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.4.120/build/pdf.min.js';\n      document.head.appendChild(pdfJsScript);\n      */\n      \n      console.log('[PDFCompressor] Libraries loaded');\n    } catch (error) {\n      console.error('[PDFCompressor] Error loading libraries:', error);\n      throw new Error('Failed to load required libraries');\n    }\n  }\n\n  /**\n   * Register service worker for PWA functionality\n   */\n  async registerServiceWorker() {\n    if ('serviceWorker' in navigator) {\n      try {\n        this.serviceWorkerRegistration = await navigator.serviceWorker.register('./service-worker.js');\n        console.log('[PDFCompressor] Service Worker registered:', this.serviceWorkerRegistration);\n        \n        // Listen for updates\n        this.serviceWorkerRegistration.addEventListener('updatefound', () => {\n          console.log('[PDFCompressor] Service Worker update found');\n          this.showUpdateNotification();\n        });\n      } catch (error) {\n        console.error('[PDFCompressor] Service Worker registration failed:', error);\n      }\n    } else {\n      console.warn('[PDFCompressor] Service Worker not supported');\n    }\n  }\n\n  /**\n   * Setup event listeners for the application\n   */\n  setupEventListeners() {\n    // DOM Content Loaded\n    document.addEventListener('DOMContentLoaded', () => {\n      console.log('[PDFCompressor] DOM Content Loaded');\n    });\n    \n    // Online/Offline events\n    window.addEventListener('online', () => {\n      console.log('[PDFCompressor] Online');\n      this.state.isOnline = true;\n      this.updateOnlineStatus();\n    });\n    \n    window.addEventListener('offline', () => {\n      console.log('[PDFCompressor] Offline');\n      this.state.isOnline = false;\n      this.updateOnlineStatus();\n    });\n    \n    // Window resize for responsive UI\n    window.addEventListener('resize', this.debounce(() => {\n      console.log('[PDFCompressor] Window resized');\n      // Trigger UI updates if needed\n    }, 250));\n    \n    // Visibility change for pause/resume\n    document.addEventListener('visibilitychange', () => {\n      this.state.isVisible = !document.hidden;\n      console.log(`[PDFCompressor] Visibility changed: ${this.state.isVisible ? 'visible' : 'hidden'}`);\n      \n      // Pause/resume processing if needed\n      if (this.state.isProcessing) {\n        if (this.state.isVisible) {\n          console.log('[PDFCompressor] Resuming processing');\n        } else {\n          console.log('[PDFCompressor] Pausing processing');\n        }\n      }\n    });\n  }\n\n  /**\n   * Setup PWA features\n   */\n  setupPWAFeatures() {\n    // Install prompt handling\n    window.addEventListener('beforeinstallprompt', (e) => {\n      console.log('[PDFCompressor] Install prompt available');\n      e.preventDefault();\n      this.deferredPrompt = e;\n      this.uiController.showInstallPrompt();\n    });\n    \n    // Handle app installed event\n    window.addEventListener('appinstalled', () => {\n      console.log('[PDFCompressor] App installed');\n      this.uiController.hideInstallPrompt();\n    });\n  }\n\n  /**\n   * Handle files shared via Web Share Target API\n   */\n  handleShareTarget() {\n    // Check if launched from share target\n    const urlParams = new URLSearchParams(window.location.search);\n    const action = urlParams.get('action');\n    \n    if (action === 'share') {\n      console.log('[PDFCompressor] Launched from share target');\n      // Handle shared files - would need server-side processing\n      // or use the Share Target API with POST requests\n    }\n  }\n\n  /**\n   * Handle files opened via File Handler API\n   */\n  handleFileHandler() {\n    // Check if launched from file handler\n    const urlParams = new URLSearchParams(window.location.search);\n    const action = urlParams.get('action');\n    \n    if (action === 'open') {\n      console.log('[PDFCompressor] Launched from file handler');\n      // Handle opened files - would need server-side processing\n    }\n  }\n\n  /**\n   * Show install prompt for PWA\n   */\n  showInstallPrompt() {\n    this.uiController.showInstallPrompt();\n  }\n\n  /**\n   * Hide install prompt\n   */\n  hideInstallPrompt() {\n    this.uiController.hideInstallPrompt();\n  }\n\n  /**\n   * Show update notification\n   */\n  showUpdateNotification() {\n    // In a real implementation, we would show a notification\n    // that a new version is available\n    this.uiController.showUpdateAvailable();\n    console.log('[PDFCompressor] New version available - please refresh');\n  }\n\n  /**\n   * Update online status UI\n   */\n  updateOnlineStatus() {\n    if (this.state.isOnline) {\n      this.uiController.hideOfflineMode();\n    } else {\n      this.uiController.showOfflineMode();\n    }\n  }\n\n  /**\n   * Handle file selection (drag and drop or file input)\n   * @param {File} file - The selected file\n   */\n  async handleFileSelection(file) {\n    try {\n      // Validate file\n      if (!this.validateFile(file)) {\n        return;\n      }\n      \n      // Set current file in state\n      this.state.currentFile = file;\n      \n      // Load PDF document\n      const result = await this.pdfProcessor.loadPDF(file);\n      this.state.pdfDocument = result.pdfDoc;\n      \n      // Show file info in UI\n      this.uiController.showFileInfo(result.metadata);\n      \n      console.log(`[PDFCompressor] File loaded: ${file.name}`);\n    } catch (error) {\n      console.error('[PDFCompressor] Error handling file:', error);\n      this.showErrorMessage('Error loading file: ' + error.message);\n    }\n  }\n\n  /**\n   * Validate selected file\n   * @param {File} file - The file to validate\n   * @returns {boolean} True if file is valid\n   */\n  validateFile(file) {\n    // Check file type\n    if (file.type !== 'application/pdf' && !file.name.toLowerCase().endsWith('.pdf')) {\n      this.showErrorMessage('Please select a valid PDF file');\n      return false;\n    }\n    \n    // Check file size (max 500MB)\n    const maxSize = 500 * 1024 * 1024; // 500MB in bytes\n    if (file.size > maxSize) {\n      this.showErrorMessage(`File size exceeds 500MB limit. Selected file: ${this.formatFileSize(file.size)}`);\n      return false;\n    }\n    \n    return true;\n  }\n\n  /**\n   * Process the current PDF with selected options\n   */\n  async processPDF() {\n    if (!this.state.currentFile || !this.state.pdfDocument) {\n      this.showErrorMessage('No PDF file selected');\n      return;\n    }\n    \n    try {\n      this.state.isProcessing = true;\n      \n      // Start performance tracking\n      this.startPerformanceTracking();\n      \n      // Process PDF based on options\n      const result = await this.pdfProcessor.processPDF(\n        this.state.currentFile,\n        this.state.processingOptions\n      );\n      \n      // End performance tracking\n      this.endPerformanceTracking();\n      \n      // Save result to storage\n      await this.storageManager.saveResult(result);\n      \n      // Show results in UI\n      this.uiController.showResults(result);\n      \n      this.state.isProcessing = false;\n    } catch (error) {\n      this.state.isProcessing = false;\n      console.error('[PDFCompressor] Error processing PDF:', error);\n      this.showErrorMessage('Error processing PDF: ' + error.message);\n    }\n  }\n\n  /**\n   * Start performance tracking\n   */\n  startPerformanceTracking() {\n    this.performance.startTime = performance.now();\n    performance.mark('processing-start');\n  }\n\n  /**\n   * End performance tracking\n   */\n  endPerformanceTracking() {\n    this.performance.endTime = performance.now();\n    performance.mark('processing-end');\n    performance.measure('processing-duration', 'processing-start', 'processing-end');\n    \n    const duration = this.performance.endTime - this.performance.startTime;\n    console.log(`[PDFCompressor] Processing completed in ${duration.toFixed(2)}ms`);\n  }\n\n  /**\n   * Show processing results\n   * @param {Object} result - Processing result\n   */\n  showProcessingResults(result) {\n    this.uiController.showResults(result);\n  }\n\n  /**\n   * Show error message to user\n   * @param {string} message - Error message to display\n   */\n  showErrorMessage(message) {\n    // Show error in UI\n    this.uiController.showNotification(message, 'error');\n    console.error('[PDFCompressor] Error:', message);\n  }\n\n  /**\n   * Format file size for display\n   * @param {number} bytes - File size in bytes\n   * @returns {string} Formatted file size\n   */\n  formatFileSize(bytes) {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n\n  /**\n   * Generate a new file name based on original and processing options\n   * @param {string} originalName - Original file name\n   * @param {Object} options - Processing options\n   * @returns {string} New file name\n   */\n  generateFileName(originalName, options) {\n    const nameWithoutExt = originalName.replace(/\\.[^/.]+$/, \"\");\n    const extension = '.pdf';\n    \n    let suffix = '';\n    if (options.imageCompression) {\n      suffix += `-compressed-${options.imageQuality}`;\n    }\n    if (options.removeImages) {\n      suffix += '-no-images';\n    }\n    if (options.splitPDF) {\n      suffix += '-split';\n    }\n    \n    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');\n    \n    return `${nameWithoutExt}${suffix}-${timestamp}${extension}`;\n  }\n\n  /**\n   * Debounce function to limit rate of function execution\n   * @param {Function} func - Function to debounce\n   * @param {number} wait - Wait time in milliseconds\n   * @returns {Function} Debounced function\n   */\n  debounce(func, wait) {\n    let timeout;\n    return function executedFunction(...args) {\n      const later = () => {\n        clearTimeout(timeout);\n        func(...args);\n      };\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n    };\n  }\n\n  /**\n   * Throttle function to limit rate of function execution\n   * @param {Function} func - Function to throttle\n   * @param {number} limit - Limit time in milliseconds\n   * @returns {Function} Throttled function\n   */\n  throttle(func, limit) {\n    let inThrottle;\n    return function(...args) {\n      if (!inThrottle) {\n        func.apply(this, args);\n        inThrottle = true;\n        setTimeout(() => inThrottle = false, limit);\n      }\n    };\n  }\n\n  /**\n   * Update processing options\n   * @param {Object} options - New options\n   */\n  updateProcessingOptions(options) {\n    this.state.processingOptions = { ...this.state.processingOptions, ...options };\n    console.log('[PDFCompressor] Processing options updated:', this.state.processingOptions);\n  }\n\n  /**\n   * Add task to processing queue\n   * @param {Object} task - Task to add\n   */\n  addToQueue(task) {\n    this.state.processingQueue.push(task);\n    console.log(`[PDFCompressor] Task added to queue. Queue length: ${this.state.processingQueue.length}`);\n  }\n\n  /**\n   * Process next task in queue\n   */\n  async processNextInQueue() {\n    if (this.state.processingQueue.length > 0) {\n      const task = this.state.processingQueue.shift();\n      console.log('[PDFCompressor] Processing next task in queue');\n      // Process task\n    }\n  }\n}\n\n// Initialize the app when the DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n  window.pdfCompressorApp = new PDFCompressorApp();\n});\n\n// Export for potential use in other modules\nexport { PDFCompressorApp };","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t524: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkpdf_compressor_pwa\"] = self[\"webpackChunkpdf_compressor_pwa\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","__webpack_require__.nc = undefined;","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [96], () => (__webpack_require__(554)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","UIController","constructor","instance","this","elements","state","isDragging","isProcessing","isMobile","window","innerWidth","darkMode","detectSystemTheme","currentTheme","animationFrame","init","cacheElements","bindEvents","setupObservers","applyTheme","handleResize","dropArea","document","getElementById","fileInput","browseBtn","fileInfoPanel","fileName","fileSize","pageCount","imageCount","tabs","querySelectorAll","tabPanes","imageCompressionToggle","qualitySlider","qualityValue","removeImagesToggle","splitToggle","splitByPages","splitBySize","pageRange","fileSizeLimit","pagesInput","sizeInput","resetBtn","processBtn","progressSection","progressFill","progressText","resultsSection","originalSize","compressedSize","savings","originalDownload","compressedDownload","installBanner","offlineNotification","installBtn","closeInstallBanner","mobileMenuToggle","mobileMenu","addEventListener","click","e","handleFileSelect","preventDefault","updateUploadArea","handleDrop","setupTabs","setupOptionControls","resetApp","handleProcess","handleInstall","hideInstallPrompt","toggleMobileMenu","handleKeyboardNavigation","debounce","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","target","classList","add","threshold","el","observe","triggerAnimation","remove","showFileInfo","metadata","textContent","formatFileSize","style","display","resetUploadArea","value","files","length","file","processSelectedFile","dataTransfer","name","size","Math","floor","random","tab","switchTab","clickedTab","t","p","tabId","getAttribute","pane","toggleOption","checked","updateQualitySlider","toggleSplitControls","updateSplitControls","validateInputs","optionName","method","visible","splitOptions","querySelector","isValid","offsetParent","test","parseInt","isNaN","showProgress","updateProgress","percent","message","width","hideProgress","showResults","originalFile","processedFile","savingsBytes","savingsPercentage","handleDownload","createResultCard","card","createElement","className","innerHTML","id","url","URL","createObjectURL","a","href","download","body","appendChild","setTimeout","removeChild","revokeObjectURL","clearResults","showNotification","type","arguments","undefined","notification","closeBtn","parentNode","showOfflineMode","hideOfflineMode","showUpdateAvailable","showInstallPrompt","adaptLayout","contains","container","key","manageFocus","updateAria","element","attribute","setAttribute","announceToScreenReader","liveRegion","position","left","animationName","cancelAnimationFrame","requestAnimationFrame","func","wait","timeout","_len","args","Array","_key","clearTimeout","later","toggleDarkMode","savePreference","localStorage","setItem","matchMedia","matches","bytes","i","log","parseFloat","pow","toFixed","progress","interval","setInterval","clearInterval","uiController","PDFProcessor","worker","isWorkerSupported","Worker","taskCounter","initWorker","Error","workerBlob","Blob","location","origin","workerUrl","setupWorkerMessaging","Promise","resolve","reject","readyHandler","event","data","removeEventListener","error","onmessage","taskId","result","percentage","performance","pendingTasks","onerror","generateTaskId","Date","now","loadPDF","validatePDF","arrayBuffer","pdfDoc","PDFDocument","load","updateMetadata","parseSpeed","extractMetadata","compressImages","quality","progressCallback","compressImagesWithWorker","workerError","pages","getPages","total","page","round","pdfBytes","save","taskPromise","progressHandler","cleanupHandler","postMessage","payload","removeImages","removeImagesWithWorker","startPage","endPage","splitByPagesWithWorker","getPageCount","newPdfDoc","create","copiedPage","copyPages","addPage","maxSizeMB","maxSizeBytes","chunks","chunkEndPage","estimateOptimalChunkEnd","chunkDoc","push","chunk","totalChunks","low","high","optimalEnd","mid","optimizePDF","optimizePDFWithWorker","processPDF","options","processedDoc","imageCompression","imageQuality","splitPDF","splitMethod","start","end","split","map","Number","newFileName","generateFileName","File","estimateCompression","processingTime","toLowerCase","endsWith","info","getTitle","replace","author","getAuthor","subject","getSubject","keywords","getKeywords","creator","getCreator","producer","getProducer","creationDate","getCreationDate","modificationDate","getModificationDate","title","generateThumbnail","originalName","nameWithoutExt","suffix","toISOString","slice","terminateWorker","terminate","StorageManager","dbName","dbVersion","db","cacheName","sessionPrefix","storageQuota","storageUsage","initDB","initCache","setupEventListeners","indexedDB","request","open","onsuccess","onupgradeneeded","objectStoreNames","fileStore","createObjectStore","keyPath","createIndex","unique","resultsStore","caches","handleStorageChange","bind","monitorStorageUsage","saveFile","store","transaction","objectStore","fileData","generateId","fileType","dateAdded","putInStore","handleStorageError","getFile","getFromStore","blob","deleteFile","deleteFromStore","getAllFiles","getAllFromStore","clearOldFiles","daysOld","cutoffDate","setDate","getDate","oldFiles","filter","deletedCount","saveResult","originalArrayBuffer","processedArrayBuffer","resultData","dateProcessed","getResult","getAllResults","deleteResult","cacheProcessedPDF","filename","cache","response","Response","put","getCachedPDF","match","clearCache","delete","getCacheSize","keys","saveSettings","settings","settingsData","lastUpdated","syncWithLocalStorage","loadSettings","localStorageSettings","getItem","JSON","parse","resetSettings","removeItem","checkStorageQuota","navigator","storage","estimate","quota","usage","requestPersistentStorage","persist","saveToSession","fullKey","sessionStorage","stringify","getFromSession","item","clearSession","Object","startsWith","exportData","sessionData","cleanKey","arrayBufferToBase64","exportDate","json","importData","text","isArray","base64ToArrayBuffer","then","cleanup","garbageCollect","close","operation","useMemoryStorageFallback","toString","substr","get","getAll","buffer","binary","Uint8Array","byteLength","String","fromCharCode","btoa","base64","binaryString","atob","charCodeAt","storageManager","PDFCompressorApp","pdfProcessor","currentFile","pdfDocument","processingOptions","processingQueue","isOnline","onLine","isVisible","startTime","endTime","memoryUsage","deferredPrompt","serviceWorkerRegistration","initializeApp","checkAPISupport","loadLibraries","registerServiceWorker","setupPWAFeatures","handleShareTarget","handleFileHandler","showErrorMessage","requiredAPIs","api","FileReader","FileList","prototype","serviceWorker","register","showUpdateNotification","updateOnlineStatus","hidden","URLSearchParams","search","handleFileSelection","validateFile","startPerformanceTracking","endPerformanceTracking","mark","measure","showProcessingResults","throttle","limit","inThrottle","_len2","_key2","apply","updateProcessingOptions","addToQueue","task","processNextInQueue","shift","pdfCompressorApp","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","r","n","getter","__esModule","d","definition","o","defineProperty","enumerable","obj","prop","hasOwnProperty","call","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","some","chunkLoadingGlobal","self","nc","__webpack_exports__"],"sourceRoot":""}